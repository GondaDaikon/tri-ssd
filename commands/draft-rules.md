---
description: L2実装ルールのたたき台を生成する
argument-hint: "[--minimal] - オプション: --minimal（最小限の骨格のみ生成）"
allowed-tools: Read, Write, Edit, Glob, Grep, WebSearch
---

# 実装ルール生成コマンド

<tri_ssd_context>
Tri-SSD（Tri-Layer Slice Spec Driven）はAI/LLMコードエージェントを前提とした仕様駆動開発。

レイヤー構造:
- L1: ビジョン・要求（docs/l1_vision.md）
- L2: 技術基盤（docs/l2_system/）- foundation.md, phases.md, rules.md
- L3: 機能仕様（docs/l3_features/PH-xxx_name/F-xxx.md）

ID形式: PREFIX-YYYYMMDD-nnn（REQ, PH, F, NF）
ステータス: draft → reviewed → implemented（L3のみ）
</tri_ssd_context>

## 概要

L2 foundation.mdの技術スタックとL1のドメインルールを基に、実装ルールの**たたき台**を生成する。

> **重要**: このコマンドで生成されるのは初期版であり、L3実装を通じて継続的に更新・進化させることを前提とする。

## 生成時の原則

<avoid_over_engineering>
- **最小限から始める**: 最初から完璧なルール集を目指さない
- 確実に必要なルールのみ生成し、L3実装で発見したルールを追加する
- 「念のため」でルールを追加しない（実際に問題が起きてから追加）
- WebSearch結果を全て取り込まない（プロジェクトに関係するものだけ選別）
- ルールの数より質を重視する
</avoid_over_engineering>

## 引数

- `--minimal`: 最小限の骨格のみ生成（セクション見出しと空欄）

## 前提条件

- `/draft-l2` が完了していること（`docs/l2_system/foundation.md` が存在）
- `docs/l1_vision.md` が存在すること

## 前提処理

1. `docs/l2_system/foundation.md` を読み込み、以下を把握:
   - 技術スタック
   - **セキュリティ方針**（認証・認可、データ保護）
   - **エラーハンドリング方針**（エラー分類、コード体系）
   - **ログ・監視方針**（ログレベル、出力ガイドライン）
2. `docs/l1_vision.md` を読み込み、ドメインルール・制約を把握
3. **`docs/l2_system/rules.md` が存在するか確認**（再生成モード判定）

---

## 出力フォーマット（必須）

### YAMLフロントマター

```yaml
---
id: RULES-YYYYMMDD-nnn
kind: rules
layer: L2
status: active
doc_status: draft
---
```

**重要**: フロントマターは必ず上記形式で出力する。`---` で囲み、インデントなし。

### 必須構造

```markdown
# [プロダクト名] 実装ルール

## 1. コード規約

### 1.1 言語・バージョン
- [言語]: [バージョン]

### 1.2 命名規則
| 対象 | 規則 | 例 |
|------|------|-----|

### 1.3 ディレクトリ構成
（プロジェクトのディレクトリ構成ルール）

### 1.4 禁止事項
- [ ] ...

## 2. アーキテクチャルール

### 2.1 レイヤ構造
（foundation.md のレイヤ構造に準拠）

### 2.2 依存関係ルール
- ...

## 3. ドメインルール
（L1から抽出したビジネスルール）

## 4. データアクセスルール

### 4.1 ORM/クエリ規約
### 4.2 トランザクション規約

## 5. セキュリティ・ログルール
（foundation.md の方針に準拠）

## 6. テストルール

### 6.1 テスト命名規則
### 6.2 テストカバレッジ基準

## 7. AI/コード生成固有の禁止事項

- [ ] 実装済みのコードを無断で大幅に変更しない
- [ ] foundation.md/rules.md に記載のない技術を勝手に導入しない
- [ ] L3に記載のない機能を追加しない
- [ ] エラーコード体系を勝手に変更しない

## 更新履歴
| 日付 | 変更内容 | 担当 | 追加理由 |
```

**必須**: セクション 1, 5, 7
**育成前提**: このドキュメントはL3実装を通じて継続的に更新される

## 再生成モード（既存ファイルがある場合）

既存の `rules.md` がある場合は**再生成モード**で動作する。

rules.md は L3 実装を通じて育てるドキュメントなので、**追記されたルールの保持が最重要**。

### 保持するもの（上書きしない）

| セクション | 理由 |
|-----------|------|
| L3実装で追加されたルール | 実装経験から得た知見は最重要資産 |
| 更新履歴（全て） | ルール追加の理由・経緯を保持 |
| ドメインルール（手動追記分） | ビジネス固有のルールを保持 |
| AI固有の禁止事項（カスタマイズ分） | プロジェクト固有の制約を保持 |

### 更新するもの

| セクション | 条件 |
|-----------|------|
| コード規約（言語/FW部分） | foundation.mdの技術スタック変更時 |
| アーキテクチャ（レイヤ構造） | foundation.md変更時 |
| API・データアクセス規約 | foundation.md変更時 |

### 再生成時の手順

1. 既存ファイルを読み込み、各セクションの内容を把握
2. **手動追記されたルール**を識別（更新履歴から判断）
3. foundation.mdとの差分を分析
4. ユーザーに「何を更新するか」を確認
5. 手動追記ルールは全て保持、foundation由来の部分のみ更新
6. 更新履歴に今回の変更を追記

### 再生成のユースケース

- foundation.md の技術スタック変更時 → `/draft-rules` で再生成
- コード規約のFW部分のみ更新、L3実装で追加したルールは保持

## 生成手順

### Step 1: 技術スタック抽出

L2 foundation.mdから以下を抽出:
- 使用言語・バージョン
- フレームワーク
- ORM/DB
- 状態管理ライブラリ
- テストツール

### Step 2: L1からドメインルール抽出

L1から以下を抽出:
- 「制約条件」セクションの内容
- 「〜してはいけない」「〜は必ず〜」などの記述
- ビジネス上の絶対ルール

### Step 3: foundation.mdの方針をルール化

foundation.mdから以下を実装ルールに変換:

| foundation.mdセクション | 生成するルール |
|------------------------|---------------|
| セキュリティ方針 | 認証・認可の実装ルール、データ保護ルール |
| エラーハンドリング方針 | エラーコード使用ルール、エラーレスポンス形式 |
| ログ・監視方針 | ログ出力ルール（何をどのレベルで） |
| 開発環境要件 | 環境固有の制約（使用禁止ライブラリ等） |

### Step 4: ベストプラクティス検索（WebSearch）

各技術について**並列で**検索:
- `[技術名] best practices [年]`
- `[技術名] common mistakes`
- `[技術名] anti-patterns`

<thinking_process>
検索結果のフィルタリング基準：

1. **このプロジェクトに適用可能か？**
   - プロジェクト規模に合っているか
   - 技術スタックと整合性があるか

2. **本当に必要なルールか？**
   - 実際に問題が起きやすい領域か
   - チームの経験レベルを考慮

3. **具体的に記述できるか？**
   - 「適切に〜」ではなく具体的に書けるか
   - 違反を検出できるか
</thinking_process>

**上記の基準でフィルタリングした上で**、以下を抽出:
- 禁止事項（やってはいけないこと）
- 必須事項（必ずやるべきこと）
- 推奨事項（やった方がよいこと）

### Step 5: ルール生成

テンプレートに沿って以下を生成:

| セクション | 生成方法 |
|-----------|---------|
| 1. コード規約 | 技術スタック + 検索結果から |
| 2. アーキテクチャ | L2 foundation（レイヤ構造）から |
| 3. ドメインルール | L1抽出から |
| 4. API・データアクセス | エラーハンドリング方針 + 検索結果から |
| 5. セキュリティ・ログ | セキュリティ方針 + ログ方針から |
| 6. テスト | L2 foundation + 検索結果から |
| 7. AI固有の禁止事項 | テンプレート固定 |

### Step 6: 対話による確認

以下をユーザーに確認:
- 命名規則の好み（既存プロジェクトがある場合）
- ディレクトリ構成の既存ルール
- プロジェクト固有の制約

## ID採番ロジック

1. 現在日時を取得: YYYYMMDD
2. 既存RULES IDを検索（Grepで docs/**/*.md から）
3. 同日の最大連番 + 1 で新ID生成
4. 形式: `RULES-YYYYMMDD-nnn`

## 出力ファイル

| モード | ファイル |
|--------|---------|
| 通常 | `docs/l2_system/rules.md` |
| --minimal | `docs/l2_system/rules.md`（骨格のみ） |

## 生成時の注意

- **foundation.mdとの整合性**: セキュリティ方針・エラーコード体系はfoundation.mdと矛盾しないこと
- **具体的に書く**: 「適切に〜」ではなく、具体的なルールを書く
- **理由を明記**: なぜそのルールが必要か、更新履歴に理由を残す

## 完了後の案内

- 生成ファイルのパスを報告
- 「これは**たたき台**です。L3実装を通じて継続的に更新してください」と案内
- 「foundation.mdのセキュリティ方針・エラー方針と整合性を確認してください」と案内
- `/gen-l3` で L3 生成できることを案内
- ルール追加の判断基準を説明

## 注意事項

- 検索結果は参考情報であり、プロジェクトに適さないルールは削除してよい
- 最初から完璧を目指さない（L3実装で育てる）
- 不明な部分は空欄のまま生成し、後で埋める
- **エラーコード体系はfoundation.mdで定義済み**なので、rules.mdでは「その体系に従う」と記載する
