---
description: L3 フェーズ（機能+受け入れ条件）を生成する
argument-hint: "[PH-xxx] - 特定フェーズのみ生成（省略時は全フェーズ計画）"
allowed-tools: Read, Write, Edit, Glob, Grep
---

# L3 フェーズ生成コマンド

<tri_ssd_context>
Tri-SSD（Tri-Layer Slice Spec Driven）はAI/LLMコードエージェントを前提とした仕様駆動開発。

レイヤー構造:
- L0: アイディア・ラフメモ（docs/l0_ideas/）- 任意
- L1: 要件（docs/l1_requirements/vision.md）
- L2: システム構成（docs/l2_foundation/foundation.md）
- L3: フェーズ（docs/l3_phases/PH-xxx.md）- 機能+受け入れ条件

ID形式: PREFIX-YYYYMMDD-nnn（REQ, PH, F）
</tri_ssd_context>

## 概要

L1/L2 をベースに、L3 フェーズドキュメントを生成する。
各フェーズは独立したファイルとして `docs/l3_phases/` に配置。

**フェーズ = 実装単位**。機能と受け入れ条件をインラインで記述。

## 生成時の原則

<avoid_over_engineering>
- **フェーズを細かく分けすぎない**: 2〜4フェーズ程度が適切
- 各フェーズは「デモ可能な成果物」を出せる単位にする
- 受け入れ条件は1機能につき2〜5個程度（10個以上は過剰）
- 最初のフェーズは小さく、早く成果を出せる構成にする
- 詳細はコード生成時にAIが考える（ここでは概要レベル）
</avoid_over_engineering>

## 引数

- `$1` (省略可): 対象フェーズID
  - **省略**: 全体計画（複数フェーズを提案）
  - **PH-xxx**: 特定フェーズのみ生成・更新

### 使用例

```
/gen-l3                           # 全体計画（2〜4フェーズ提案）
/gen-l3 PH-20250203-001           # 特定フェーズを再生成
```

## 前提処理

1. `docs/l1_requirements/vision.md` を読み込み、要件を把握する
2. `docs/l2_foundation/foundation.md` を読み込み、技術スタックを把握する
3. `docs/l3_phases/` 内の既存フェーズを確認（再生成モード判定）

---

## 出力フォーマット（必須）

### YAMLフロントマター（各フェーズファイル）

```yaml
---
status: wip
---
```

### 必須構造（各フェーズファイル）

```markdown
# PH-xxx: [フェーズ名]

## 目的
このフェーズで達成すること（1-2文）

## 機能一覧

### F-xxx: [機能名]
**対応REQ**: REQ-xxx

[機能の概要説明（2-3行）]

**受け入れ条件**:
- [ ] [条件1]
- [ ] [条件2]
- [ ] [条件3]

---

### F-xxx: [機能名]
**対応REQ**: REQ-xxx

[機能の概要説明]

**受け入れ条件**:
- [ ] [条件1]
- [ ] [条件2]

---

## Exit Criteria
- [ ] [フェーズ完了の確認項目1]
- [ ] [フェーズ完了の確認項目2]
```

**必須**: 目的、機能一覧（受け入れ条件付き）、Exit Criteria
**省略可能**: 複雑な機能のみ追加説明

---

## 再生成モード（既存ファイルがある場合）

既存のフェーズファイルがある場合は**再生成モード**で動作する。

### 保持するもの（上書きしない）

| セクション | 理由 |
|-----------|------|
| 受け入れ条件のチェック状態 | 進捗を保持（`[x]` を消さない） |
| Exit Criteria のチェック状態 | 進捗を保持 |
| 実装メモ（あれば） | 知見を保持 |
| status: done のファイル | 完了済みを保護 |

### 更新するもの

| セクション | 条件 |
|-----------|------|
| 機能の概要 | L1要件が変更された場合 |
| 受け入れ条件（未チェック分） | 要件変更時 |
| 新規機能の追加 | L1に新しいREQが追加された場合 |

### 再生成時の手順

1. 既存ファイルを読み込み、チェック状態を把握
2. L1/L2との差分を分析
3. ユーザーに「何を更新するか」を確認
4. 完了済み項目は保持、未着手部分のみ更新

---

## 生成手順

### Step 1: 全体フェーズ計画（引数なしの場合）

1. L1の要件を機能候補に分解
2. 機能を「結合して意味のある単位」でグルーピング
3. フェーズ数を決定（2〜4フェーズ推奨）
4. ユーザーにフェーズ計画を提示して確認

<thinking_process>
フェーズ設計前に、以下を判断する：

1. **適切なフェーズ数は？**
   - 小規模（機能5個以下）: 2フェーズ
   - 中規模（機能6〜15個）: 3フェーズ
   - 大規模（機能16個以上）: 4フェーズ

2. **各フェーズの境界は？**
   - 「この時点でユーザーに見せられるか？」で判断
   - 技術的な区切りより、ビジネス価値の区切りを優先

3. **最初のフェーズに何を入れるか？**
   - 早く成果を出せる機能を優先
   - 依存関係の根幹となる機能を含める

4. **Phase 0（環境構築）は必要か？**
   - リポジトリ初期設定、CI、リンター/フォーマッター
   - 小規模・個人開発なら最初のフェーズに含める
   - チーム開発や複雑な環境設定が必要なら独立フェーズに
</thinking_process>

### Step 2: 機能分解とID採番

- L1の各REQを機能に分解
- 機能IDは F-YYYYMMDD-nnn 形式で採番
- 各機能に対応REQを紐付け

### Step 3: 受け入れ条件の記述

各機能に対して:
- ユーザー視点で「何ができればOKか」を記述
- 1機能につき2〜5個程度
- テスト可能な形で書く（曖昧な表現を避ける）

**良い例**:
- [ ] タイトル入力→作成→一覧に表示される
- [ ] タイトル空で送信→エラーメッセージ表示

**悪い例**:
- [ ] 適切に動作する ← 曖昧
- [ ] エラーハンドリングが実装されている ← 何のエラー？

### Step 4: Exit Criteria の設定

各フェーズの完了条件を設定:
- 全機能の受け入れ条件がパスしている
- 結合テストがパスしている（必要な場合）
- デモ可能な状態になっている

### Step 5: ファイル生成

フェーズごとに独立ファイルを生成:
```
docs/l3_phases/
├── PH-20250203-001_mvp.md
├── PH-20250203-002_beta.md
└── PH-20250203-003_release.md
```

---

## ID採番ロジック

### フェーズID（PH）
1. 現在日時を取得: YYYYMMDD
2. 既存PH IDを検索（Grepで docs/**/*.md から）
3. 同日の最大連番 + 1 で新ID生成

### 機能ID（F）
1. 現在日時を取得: YYYYMMDD
2. 既存F IDを検索（Grepで docs/**/*.md から）
3. 同日の最大連番 + 1 で新ID生成

## 出力ファイル

| ファイル |
|---------|
| `docs/l3_phases/PH-YYYYMMDD-nnn_[phase-name].md` |

ファイル名: `{フェーズID}_{kebab-case-フェーズ名}.md`
例: `PH-20250203-001_mvp.md`

## 完了後の案内

- 生成ファイルのパスを報告
- フェーズ数と機能数を報告
- `/gen-code PH-xxx` または `/gen-code F-xxx` でコード生成できることを案内
- `/status` で進捗確認を案内

---

## エラーケース

| ケース | 対応 |
|--------|------|
| L1が存在しない | エラー: 「L1が見つかりません。`/gen-l1` を先に実行してください」 |
| L2が存在しない | エラー: 「L2が見つかりません。`/gen-l2` を先に実行してください」 |
| L1/L2が wip 状態 | 警告: 「L1/L2が未完了です。続行しますか？」 |
| 指定したPH-IDが存在しない | エラー: 「指定されたフェーズが見つかりません」 |
