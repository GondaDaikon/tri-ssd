---
description: L2からL3（機能ドキュメント）を生成する
argument-hint: "[F-xxxx ...] - 対象の機能ID（省略時は全体）"
allowed-tools: Read, Write, Edit, Glob, Grep
---

# L3 生成コマンド

<tri_ssd_context>
Tri-SSD（Tri-Layer Slice Spec Driven）はAI/LLMコードエージェントを前提とした仕様駆動開発。

レイヤー構造:
- L1: ビジョン・要求（docs/l1_vision.md）
- L2: 技術基盤（docs/l2_system/）- foundation.md, phases.md, rules.md
- L3: 機能仕様（docs/l3_features/F-xxx.md）

ID形式: PREFIX-YYYYMMDD-nnn（REQ, PH, F, NF）
ステータス: draft → reviewed → implemented（L3のみ）
</tri_ssd_context>

## 生成時の原則

<avoid_over_engineering>
- 機能の複雑さに応じた適切な粒度でドキュメントを生成する
- 単純なCRUD機能に詳細な状態遷移図やシーケンス図は不要
- テンプレートの全セクションを埋める必要はない（該当しないセクションは省略）
- 受け入れ条件は3〜5個程度で十分（10個以上は過剰）
- 「念のため」でセクションを追加しない
</avoid_over_engineering>

## 引数

- `$ARGUMENTS`: 対象の機能ID（省略可、複数指定可）
  - 指定時: 指定された F-xxxx のみを対象
  - 省略時: L2 の機能一覧全体を対象

## 前提処理

1. `templates/l3_feature.md` を読み込み、L3テンプレートを確認する
2. `docs/l2_system/foundation.md` を読み込み、技術方針・NFRカタログを把握する
3. `docs/l2_system/phases.md` を読み込み、フェーズ定義・機能一覧を把握する
4. `docs/l2_system/rules.md` を読み込み、**実装ルール（コード生成制約）を把握する**（存在する場合）

## ID採番ロジック

1. 現在日時を取得: YYYYMMDD
2. 既存F IDを検索（Grepで docs/**/*.md から）
3. 同日の最大連番 + 1 で新ID生成

## 生成手順

### Step 1: 対象機能の特定
- 引数があれば指定されたF-xxxx
- なければ phases.md の全機能

### Step 2: 既存L3の確認
- `docs/l3_features/` に既存があれば確認
- **既存ファイルがある場合は再生成モードへ**

## 再生成モード（既存ファイルがある場合）

対象の L3 ファイルが既に存在する場合は**再生成モード**で動作する。

### 保持するもの（上書きしない）

| セクション | 理由 |
|-----------|------|
| 実装メモ・注意点 | 実装で得た知見は最重要資産 |
| 技術的負債・暫定対応 | 将来の改善タスクを保持 |
| 関連コードへのリンク | 実装との紐付けを保持 |
| タスクチェックリストの完了状態 | 進捗を保持（`[x]` を消さない） |
| `<!-- TODO: -->` コメントと対応メモ | 検討経緯を保持 |
| `doc_status` が `implemented` の場合 | 全体を保持、警告のみ出す |

### 更新するもの

| セクション | 条件 |
|-----------|------|
| 概要・ユースケース | L2の機能定義が変更された場合 |
| データモデル | L2/実装からのフィードバック時 |
| インターフェース | API/UI仕様変更時 |
| 業務ルール・例外 | ルール追加・変更時 |
| 受け入れ条件 | 要件変更時 |
| 未完了のタスク | 再見積もり・追加時 |

### 再生成時の手順

1. 既存ファイルを読み込み、`doc_status` を確認
2. `implemented` の場合は警告：「実装済みです。本当に再生成しますか？」
3. 保持セクション（実装メモ等）の内容を抽出・退避
4. L2との差分を分析、ユーザーに「何を更新するか」を確認
5. 仕様部分を更新、保持セクションはそのまま維持
6. 更新後、差分をユーザーに提示

### 再生成のユースケース

- 実装中に問題発見 → L3の「実装メモ」に記載 → `/gen-l3 F-xxx` で再生成
- 実装メモは保持されつつ、仕様部分のみ更新される

## 生成手順（続き）

### Step 3: 技術基盤との整合性確認

**foundation.md から確認**:
- 使用する技術スタック
- 適用するアーキテクチャパターン
- セキュリティ方針（認証・認可の適用）
- エラーハンドリング方針（エラーコード体系）

**rules.md から確認**（存在する場合）:
- 適用すべき実装ルール
- 禁止事項

### Step 4: データモデル定義

<thinking_process>
データモデル設計前に、以下を判断する：

1. **この機能にデータモデルは必要か？**
   - 表示のみの機能 → 不要
   - 既存エンティティの操作のみ → 参照のみ記載
   - 新規エンティティが必要 → 定義する

2. **状態遷移は必要か？**
   - 単純なCRUD → 不要
   - ワークフロー・承認フロー → 必要
   - 注文・予約など状態変化がある → 必要
</thinking_process>

**上記の判断を行った上で**、以下を定義（必要な場合のみ）:
- **エンティティ**: この機能で扱うデータエンティティ
- **データ構造**: 型定義（TypeScript interface等）
- **状態遷移**: 状態を持つ場合は状態遷移図とテーブル

**注**: 状態遷移は複雑な機能（ワークフロー、注文処理等）でのみ必要。無理に埋めない。

### Step 5: インターフェース設計

機能の種類に応じて適切なセクションを選択:

| 機能種別 | 記載するセクション |
|----------|-------------------|
| 画面機能 | 画面構成（ASCII図） |
| API | エンドポイント、リクエスト/レスポンス |
| CLI | コマンド形式、オプション、終了コード |
| バッチ | 入出力ファイル、実行スケジュール |

**シーケンス図**: 複数コンポーネントが連携する場合に記載

### Step 6: 業務ルール・例外定義

- **バリデーションルール**: 各入力項目のルールとエラーメッセージ
- **権限・ロール**: ロール別の許可操作と制限
- **例外ケース**: 異常系の動作と**エラーコード**（foundation.mdの体系に従う）

### Step 7: 非機能・受け入れ条件

- **NFR具体化**: foundation.mdのNFRをこの機能でどう満たすか
- **受け入れ条件**: Gherkin形式（Given-When-Then）で3つ以上

### Step 8: タスクチェックリスト

- **実装タスク**: コンポーネント作成、API実装、バリデーション等
- **テストタスク**: ユニット、結合、E2E

### Step 9: 実装メモ（初期は空または最小限）

- 適用する設計パターン（該当があれば）
- 関連コードへのリンク（実装後に埋める）
- 技術的負債・暫定対応（該当があれば）

## 出力ファイル

- パターン: `docs/l3_features/F-YYYYMMDD-nnn_[機能名].md`
- 例: `F-20250125-001_user-registration.md`

## 出力仕様

- **フロントマター**: `doc_status: draft`
- **曖昧箇所**: `<!-- TODO: 要確認 -->` でマーク
- **参照フィールド**: `req_ids`, `nfr_ids`, `phase` を正確に記載

## 生成時の注意

- **データモデルは必須セクションではない**: 単純なCRUDや表示機能では省略可
- **状態遷移は複雑な機能のみ**: 無理に埋めない
- **CLI/バッチセクション**: 該当しない場合は削除してよい
- **エラーコードはfoundation.mdの体系に従う**: 勝手に新体系を作らない

## 完了後の案内

- 生成ファイルのパスを報告
- TODO箇所の数を報告
- 「foundation.md/rules.md との整合性を確認してください」と案内
- `/check` で整合性チェックを案内
- `/review F-xxxx` でレビューを案内
