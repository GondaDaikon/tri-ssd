> **⚠️ 非推奨（Deprecated）**
>
> このドキュメントは旧バージョンの SSDD ガイドです。
> 現行バージョン（v0.5）では以下を参照してください：
> - メインガイド: `docs/guide.md`
> - 用語集: `docs/glossary.md`
> - マイグレーション: `docs/migration.md`

# SSDDサイクル開発フロー運用ガイド（Git＋エージェント版／改訂）

## 1. はじめに

### 1.1 本ガイドの目的

本ガイドは、「スライス仕様駆動開発サイクル（SlicesSpecDrivenDevelopment / SSDD）」における

* ドキュメント（第1〜第3層）の役割
* 書き方とテンプレート
* 更新・変更伝播のルール
* Git＋コードエージェント前提での運用フロー

を定義することを目的とする。

SSDDサイクルは、以下の既存の考え方をベースにしている。

* 要求工学における「ステークホルダー要求 → システム要求」の多層モデル
* MBSE/MBRE（モデルベース要求工学）
* Agile Specification-Driven Development（仕様駆動開発のアジャイル版）
* プロダクトマネジメントにおける「ビジョンドキュメント＋プロダクトバックログ／ストーリーマッピング」

これらを踏まえつつ、LLM／AIコードエージェントを前提に、
実務上のフローとアーティファクト構造を再構成した運用フレームが SSDD サイクルである。

本ガイドでは、その中でも「開発フロー」と「ドキュメント運用」にフォーカスする。

### 1.2 想定読者

* プロダクトオーナー／業務担当
* アーキテクト／テックリード／ビジネスアナリスト（BA）
* 開発者／テスター
* プロジェクトマネージャ

### 1.3 適用範囲

* 個人開発〜小〜中規模チーム
* Web / ネイティブ / デスクトップ等の一般的なアプリケーション開発
* Scrum / Kanban ベースのアジャイル開発

組織的なセキュリティ／コンプライアンス規定は本ガイドのスコープ外とする。

### 1.4 前提条件（AI／リポジトリ構成）

本ガイドは、以下を前提とする。

* 単一プロダクト、または Monorepo 内の 1 プロダクトを対象とすること
* L1〜L3 ドキュメント、catalog.yaml、ソースコードをすべて同一 Git リポジトリで管理すること
* LLM／コードエージェントを常用し、次の作業を基本的に AI 経由で行うこと

  * L1 → L2 → L3 のドラフト生成
  * ドキュメントの更新・整合性チェック
  * コード／テストのドラフト生成
* AI による生成物は、必ず人間のレビューと修正を経て確定させること

AI を用いない運用は本ガイドの対象外とし、SSDD は「AI を前提とした開発フロー」として位置づける。

---

## 2. SSDDサイクルの概要と三層モデル

### 2.1 三層構造（L1/L2/L3）

SSDDサイクルにおけるドキュメントは、次の三層で構成される。

1. 第1層（L1）：ビジョン・要求ドキュメント（人間中心・ビジョンレイヤ）
   ビジネス要求・背景・制約・願望ベースの機能／画面イメージを記録する

2. 第2層（L2）：機能設計・技術方針ドキュメント（AI中心・構造化レイヤ）
   要求を満たすための機能構成・技術スタック・フェーズ・非機能カタログを構造化する

3. 第3層（L3）：機能ドキュメント（Feature単位の実装・テスト指針）
   第2層から切り出された各機能ごとのミニ仕様＋タスク＋テスト＋実装メモを記録する

LLM／AIコードエージェントは主に

* 「第1層 → 第2層」の構造化
* 「第2層 → 第3層」の機能Docドラフト生成
* 「実装結果 → 上位層フィードバック（差分検出・修正案提示）」

を支援する。

### 2.2 ソース・オブ・トゥルースの考え方

各レイヤの「何についての正本か」を明確にする。

* 第1層（L1）：要件のソース・オブ・トゥルース

  * ビジネス要求・ユーザ要求・制約条件の「正」

* 第2層（L2）：機能構成・技術方針のソース・オブ・トゥルース

  * 要求を満たすために「何をどう作るか」の設計判断
    （機能一覧・依存・フェーズ・技術スタック・非機能カタログ）の「正」

* 第3層（L3）：実装・テストの説明ビュー

  * 各機能の具体的な作業・受け入れ条件・実装サマリ
    ※最終的な事実はコード＋テストが正

整理すると：

* 「要件の正」：第1層
* 「設計判断（どう満たすか）の正」：第2層
* 「実装された挙動の最終的な正」：コード＋テスト

第3層は、コードとテストを読み解く前の入口となる「実装・テストの解説ビュー」と位置づける。
AI にとっても、人間にとっても、コードを直接読む前に参照するビューである。

---

## 3. Git リポジトリ構成と ID カタログ

### 3.1 管理方針

ソースコードと同一 Git リポジトリ内に、L1〜L3および各種カタログを格納する。

ブランチ／タグ／Pull Request により、コードと同じフローで変更管理・レビューを行う。

ClaudeCode / Codex などのコードエージェントは、このリポジトリをコンテキストとして利用し、
必要に応じて catalog.yaml から ID 一覧やトレーサビリティ情報を取得する。

Monorepo の場合も、1プロダクトごとに docs 配下に L1〜L3 と catalog.yaml を持つ単位を切る。
プロダクト横断の共通要求がある場合は、別途 cross-product 用の catalog を設けることもできる。
（本ガイドでは、1プロダクト単位の運用のみを扱う）

### 3.2 ディレクトリ構成（例）

```text
docs/
  catalog.yaml           # REQ / F / NF / PH / SP など全IDのカタログ
  l1_vision/
    vision.md
  l2_system/
    overview.md          # 用語集・技術方針・全体構成
    phases.md            # フェーズ定義（PH-xxxx）＋各フェーズ配下の機能一覧
    nfr.md               # 非機能要求カタログ（NF-xxxx）
    features_index.md    # 機能一覧（F-xxxx）テーブル（全体の俯瞰用）
  l3_features/
    F-0001_markdown-edit.md
    F-0002_multi-tab.md
    ...
src/
  ...
```

### 3.3 ID 種類

* 要件：REQ-xxxx
* フェーズ：PH-xxxx（および検証フェーズ PH-POC-xxxx）
* 非機能要求：NF-xxxx
* 機能（Feature）：F-xxxx
* スパイク／PoC：SP-xxxx（任意）

### 3.4 catalog.yaml の役割

docs/catalog.yaml は、全IDの**横断カタログ（正本）**として扱う。

各IDの

* id / kind / layer / title / status
* 関係フィールド（req_ids / nfr_ids / phase / related_nfr_ids など）

を 1 ファイルに集約する。

AI は catalog.yaml を読み込むことで、各ドキュメントをまたいだトレーサビリティ情報を把握できる。

### 3.5 規模別の運用イメージ

* 個人開発：

  * catalog.yaml には、まずは `id / kind / title` 程度の最低限の情報から始めてよい。
  * 整合性チェックは、リリース前や区切りのタイミングで AI に
    「catalog.yaml と docs/ 配下のファイルの ID をチェックして、不整合だけ教えて」
    と投げる運用でも十分とする。
* 小〜中規模チーム：

  * catalog.yaml の項目（id / kind / layer / title / status / 主要な参照フィールド）を揃え、
    レビュー時に AI で整合性チェックを走らせることを推奨する。
  * ID が増えて管理が重くなってきた場合は、REQ / F / NF / PH ごとにファイル分割し、
    スクリプトやAIで集約する運用も検討する。

---

## 4. YAMLフロントマターと doc_status

### 4.1 共通フィールド

単一IDを表す Markdown ファイルは、先頭に以下のフロントマターを持てる。

* id：一意なID（REQ-0001 等）
* kind：req / feature / nfr / phase / spike / vision など
* layer：L1 / L2 / L3 / meta
* title：人間向けタイトル
* status：active / deprecated / removed
* doc_status：draft / reviewed / implemented など

本文内に同じメタ情報を重複して書かず、フロントマターをメタ情報の正本とする。
AI も、まずフロントマターを参照してから本文を処理する。

AI が生成したドキュメントは、原則として `doc_status: draft` から開始し、
人間のレビュー・修正を経て `reviewed / implemented` に更新する。

### 4.2 status（ライフサイクル）

* active：現役。変更・拡張の対象。
* deprecated：廃止予定・移行中。可能であれば replaced_by で後継IDを記録。
* removed：廃止済み。履歴としてのみ残し、新規からは参照しない。

### 4.3 doc_status（文書・開発状態）

* draft：AIドラフトや書きかけ。レビュー前。
* reviewed：人間が内容を確認し、実装／運用に使えるレベル。
* implemented（主にL3）：実装・テスト完了済みで、ドキュメントも追従している。

### 4.4 規模別の運用イメージ

* 個人開発：

  * doc_status は `draft / reviewed / implemented` の3つに絞ってよい。
  * AIがドラフトを生成した直後は draft、自分で読み直して「一旦これで進める」と判断したら reviewed、
    実装とテストを終えて内容をざっくり追随させたら implemented とする。
* 小〜中規模チーム：

  * reviewed にする際に、誰がレビューしたか（reviewer）を PR やコメントで残すことを推奨する。
  * 重要な設計（アーキテクチャ方針など）は、reviewed への変更を特定ロール（アーキテクト等）に限定することも検討する。

---

## 5. 第1層（L1）：ビジョン・要求ドキュメント

### 5.1 目的・役割

プロダクトの目的・背景・制約・ビジネス要求・ユーザ要求を自然言語で記述する。

第2層が何度でも「解釈し直せる材料」を提供する。

技術的な詳細ではなく、「何のために・誰のために・どう使われるべきか」を表現する。

L1 は、ラフなメモや箇条書きから AI にドラフトを生成させ、
PO／業務担当／開発者が読みながら修正していく運用を想定する。

### 5.2 想定読者

* PO／業務担当／UX
* アーキテクト／テックリード
* ステークホルダー全般

### 5.3 記載しないもの

* クラス設計、API仕様、DBスキーマ等の具体的な技術設計
* 実装タスクの細かい分割
* ソースコード断片

### 5.4 章立て例（アウトライン）

1. ドキュメントの立ち位置

   * 目的（例：「本書は、本プロダクトのビジョン・背景・要求を記録する」）
   * 範囲（対象ドメイン・プロダクト）
   * 粒度（ソースコードは記載しない／技術詳細は第2層に委ねる など）

2. プロダクトの目的・背景

   * 解決したい課題・ペイン
   * 想定ユーザー／ペルソナ
   * ビジネス上のゴール（KPI等）

3. 制約条件・前提

   * OS／デバイス／ブラウザ等の互換性要求
   * 法規制・コンプライアンス要件
   * 外部システムとの連携前提

4. 類似・競合製品／参考サービス

   * 参考にする既存サービス
   * 真似したい点／差別化したい点

5. 実装したい機能・画面（願望リスト）

   * 機能要求を REQ-xxxx 形式でID付与して列挙
   * 利用シナリオ／ユーザストーリー
   * 簡易な画面イメージ（テキストベースでよい）

6. 非機能要求（高レベル）

   * 性能（例：「体感的にストレスのないレスポンス」）
   * セキュリティ（認証・認可レベル）
   * 可用性／拡張性／運用性に関するビジョンレベルの要望

7. 更新ルール

   * 誰が更新するか（PO, 業務担当など）
   * 変更・追記の方針（履歴管理のルール 等）

### 5.5 ID付与の基本ルール

* 要件には一意なIDを付与する：REQ-0001, REQ-0002, …
* 類似要件のグルーピングは、第2層側の責務とする（L1側は「書きやすさ」を優先してよい）。
* REQ ID の採番や命名は、AI に「この要求一覧に REQ-xxxx のIDを振って」と依頼して自動付与させてもよい。

### 5.6 規模別の運用イメージ

* 個人開発：

  * L1は `vision.md` 1ファイルに集約し、「課題・ペルソナ・願望リスト・高レベル非機能」をラフに書き出すだけでもよい。
  * REQ の詳細な説明は、必要になってから AI に「この願望リストを REQ-xxxx 形式に整理して」と依頼して整形していく。
* 小〜中規模チーム：

  * L1を「ビジョン（背景・目的）」と「要求一覧（REQ-xxxx）」で章分けして管理する。
  * 要求一覧は catalog.yaml とIDを同期させ、AIでトレーサビリティを辿りやすくする。

---

## 6. 第2層（L2）：機能設計・技術方針ドキュメント

### 6.1 目的・役割

第1層の要求を満たすための機能構成・技術スタック・フェーズ・非機能カタログを体系的に定義する。

バックログ／機能Doc／テスト計画の元データとなる「システム側のモデル」として機能する。

要求を「実装しうる形」に落とし込む責任を持つ。

L1 からの変換は、AI による「L1→L2ドラフト生成」を基本とし、
アーキテクト／テックリードがレビュー・修正して確定させる。

### 6.2 想定読者

* アーキテクト／テックリード／BA
* 開発者／テスター
* 一部 PO（全体像把握用）

### 6.3 章立て例（アウトライン）

1. ドキュメントの立ち位置・粒度

   * 「本書は、第1層の要求を満たすための機能構成・技術方針の正本である」
   * コードレベルには踏み込まないが、APIやモジュール単位までは言及しうる、など

2. 第1層の要約とトレーサビリティ方針

   * 第1層からの主要な要求サマリ
   * REQ-xxxx と本ドキュメント内の要素（F-xxxx, PH-xxxx 等）の対応ルール

3. 用語集

   * ドメイン用語・業務用語・略語・システム用語の定義
   * 出典（REQ IDや業務資料 等）があれば併記

4. 技術スタック・技術方針

   * クライアント側技術選定（例：Electron vs Tauri）
   * サーバ側技術選定（フレームワーク／言語）
   * DB／インフラ／CI/CD 等の選定方針
   * 主要な技術選定の理由と、採用しなかった選択肢のメモ
   * 必要に応じて ADR（Architectural Decision Record）へのリンク

5. 全体アーキテクチャ

   * コンポーネント構成（クライアント／サーバ／ストレージ等）
   * レイヤ構造説明（UI／アプリケーション／ドメイン／インフラ等）
   * モジュール間の依存関係の概要

6. フェーズ定義（Phase設計）

7. 機能一覧（全体俯瞰用）

8. 非機能要求カタログ（NF-xxxx）

9. 更新・変更管理

以下、フェーズ定義と機能一覧の詳細を分けて記載する。

### 6.4 フェーズ定義（Phase設計）

フェーズ（PH-xxxx）は、「結合して動かしたときに意味のある機能群」を束ねたマイルストーン単位とする。

各フェーズについて、次を定義する。

* Phase ID：PH-0001, PH-0002, …
* 名称：例「基盤Skeleton」「基本編集機能」「設定・環境周り」
* 目的：

  * 本フェーズ完了時にユーザ視点で何ができるべきか
  * アーキテクチャ視点でどこまで固めたいか
* 適用される主な非機能（NF-xxxx）
* フェーズ完了条件（Exit Criteria）
* フェーズ境界で実施するテストの種類と概要（結合テスト／E2Eテスト 等）

フェーズ定義や、フェーズ配下の機能一覧は、L1 の REQ と既存の機能構成を元に
AI に案を出させ、開発者／テックリードが並び順や内容を微調整する運用を想定する。

#### 6.4.1 フェーズ配下の機能一覧（記載順＝実装順）

各フェーズごとに、1段下げた見出し配下に「そのフェーズの対象機能一覧」を記載する。

この機能一覧の記載順序＝実装順序とみなす。

別フィールドに「実装順」カラムは持たない（ドキュメント圧縮のため）。

例：

```markdown
### 6.4.1 PH-0001 基盤Skeleton

- 目的（ユーザー／アーキ視点の説明）
- 適用NF: [NF-0001, NF-0003]
- 完了条件（Exit Criteria）:
  - アプリが起動し、空のウィンドウが表示できる
  - 最低限のログ出力が行われる

#### PH-0001 内の対象機能一覧（記載順＝実装順）

- F-0001: アプリケーション起動〜ウィンドウ表示
- F-0003: ログ出力の骨組み
- F-0005: 設定ファイルの読み込み

### 6.4.2 PH-0002 基本編集機能

- 目的（ユーザー／アーキ視点）
- 適用NF: [NF-0001, NF-0002]
- 完了条件（Exit Criteria）:
  - ユーザーがMarkdownを編集し、保存／再読み込みできる

#### PH-0002 内の対象機能一覧（記載順＝実装順）

- F-0010: Markdown編集画面の表示
- F-0011: ファイルの新規作成・保存
- F-0012: プレビュー表示
```

#### 6.4.3 検証フェーズ（PH-POC）

技術的・非機能的な不確実性が高い領域については、通常の機能フェーズとは別に
「検証フェーズ（PH-POC-xxxx）」を定義して扱う。

対象は F-xxxx ではなく SP-xxxx（スパイク／PoC）として管理する。

本番コードへの直接取り込みを前提としない実験コードを含んでもよい。

完了条件は「OK/NGの結論＋第2層への反映」。

### 6.5 機能一覧（全体俯瞰用）

「機能一覧」は、全体を俯瞰するためのテーブルとして定義し、実装順序は持たない。

* 機能ID：F-0001, F-0002, …
* 機能名
* 対応する REQ ID（複数可）
* 所属フェーズ（PH-xxxx）
* 依存関係（他のF-xxxx）
* ステータス（未着手／実装中／実装済み 等）

実装順序を変えたい場合は、各フェーズの「対象機能一覧」の並び順を変更する。

### 6.6 非機能要求カタログ（NF-xxxx）

docs/l2_system/nfr.md に、NFごとのカタログを記載する。

各NFの内容：

* ID／名称
* 説明：何を満たす必要があるか
* 適用範囲：どの機能／フェーズに適用されるか
* テスト／監視方法へのリンク（負荷試験シナリオ・モニタリング項目など）

### 6.7 更新・変更管理

* 第1層からの変更要求が来た場合の対応手順
* 第3層や実装からのフィードバックを反映する手順
* フェーズ定義や技術スタックの変更時の合意フロー（誰が合意するか）

### 6.8 規模別の運用イメージ

* 個人開発：

  * PH-0001〜0003 程度の粗いフェーズだけ決めておき、その中の F-xxxx の並び順を「実装予定順」として管理する程度でもよい。
  * 実装順を変えたくなったら、AIに「このフェーズ内の機能の順番を入れ替えて」と依頼し、該当箇所を書き換えさせる。
* 小〜中規模チーム：

  * バックログリファインメント時に、対象フェーズと F-xxxx を確認し、AIに「このフェーズの機能を優先度順に並べ替えて」と提案させる運用を推奨する。
  * 技術スタックや主要設計判断は L2 に集約し、詳細設計・実装メモは L3 に降ろす。

---

## 7. 第3層（L3）：機能ドキュメント

### 7.1 目的・役割

第2層の機能一覧から切り出し、1機能（または小さな機能群）ごとに実装・テストを行うためのミニ仕様として機能する。

実装前には「仕様＋タスク＋受入条件」として、実装後には「どう実装したかのサマリ＋コードへの入口」として機能する。

L3 の内容は、そのままコードエージェントに渡すことで、
実装コードやテストコードのドラフトを生成するためのプロンプトとしても利用する。

L3 も、基本は AI がドラフトを書き、担当開発者／テスターがレビュー・補正する。

### 7.2 想定読者

* 開発者／テスター
* コードレビュー担当者

### 7.3 機能Docの構成（例）

フロントマターでメタ情報（id, kind, layer, status, doc_status, req_ids, nfr_ids, phase）を表現し、
本文は次のような構成を推奨する。

1. 概要

   * この機能でユーザーが何をできるようになるか
   * 代表的なユースケース・シナリオ

2. 入出力・画面イメージ

   * 画面の構成要素（項目・ボタン・メニューなど）
   * APIの場合：リクエスト／レスポンスの概要
   * 必要に応じて簡易なシーケンス

3. 業務ルール・例外

   * バリデーションルール
   * 権限・ロールによる振る舞いの違い
   * 例外的なケース（エラー時の動作 等）

4. タスクチェックリスト（実装・テスト）

   * 実装タスク（チェックボックス形式）
   * テストタスク（ユニット／結合／E2Eなど）

5. 非機能・受け入れ条件

   * 関連する NF-xxxx ごとの具体化（この機能でどう満たすか）
   * Given-When-Then 等で表現した受け入れ条件の列挙

6. 実装メモ・注意点

   * 適用した設計パターン
   * 負債／暫定対応／注意点
   * 関連コードへのリンク（ファイルパスやクラス名）

実装メモには、関連するコードファイルパスやテストファイル名を簡単に記録しておくと、
後から AI に「この機能の実装とテストを見直して」と依頼しやすくなる。

> 注：第3層はあくまで「コード＋テストを理解するためのビュー」であり、
> 最終的な挙動の正しさはコード＋テストに委ねる。

### 7.4 規模別の運用イメージ

* 個人開発：

  * L3は、実装前に AI にドラフトを書かせ、「概要」「入出力」「簡単なテスト観点」だけ埋まっていればよい。
  * 実装後に、「実装メモ」に気づきや注意点を1〜2行追記するくらいの軽い運用で構わない。
* 小〜中規模チーム：

  * L3のタスクチェックリストや受け入れ条件を、レビューやテスト設計の材料として使う。
  * バグ修正や仕様変更時には、L3に一行でもいいので「何が変わったか」を追記し、AI の差分検出に活かす。

---

## 8. フェーズと結合テスト／E2Eテスト

### 8.1 フェーズの定義

フェーズ（PH-xxxx）は、第1層の要求を満たすための機能群を
「結合して動かしたときに意味のある単位」で束ねたマイルストーンと定義する。

フェーズはスプリントとは必ずしも1対1に対応しない。
1フェーズが複数スプリントをまたぐことも許容する。

### 8.2 第2層におけるフェーズ設計

第2層において、各フェーズについて以下を定義する。

* Phase ID／名称
* 目的（ユーザー視点／アーキテクチャ視点）
* 対象機能（F-xxxx、記載順＝実装順）
* 適用非機能（NF-xxxx）
* 完了条件（Exit Criteria）
* フェーズ境界で実施するテストの種類と概要（結合テスト／E2Eテスト）

### 8.3 フェーズ境界でのテストとAI活用

各フェーズ完了時には、AIを用いて結合テスト／E2Eテストシナリオのドラフトを生成する。

入力：

* 第2層のフェーズ定義
* 該当機能の L3 機能Doc

出力：

* シナリオ形式のテストケース案

フロー：

1. AIがテストシナリオ案を生成

2. テスター／開発者がレビュー・補正

3. テスト実施

4. テスト結果から得られた知見を、

   * 局所的な問題：第3層（機能Doc）＋コードに反映
   * 構造／依存の問題：第2層（フェーズ定義・機能構成）にフィードバック

---

## 9. ソース・オブ・トゥルースと変更伝播ルール

### 9.1 原則

* 第1層：要件の変更・追加は必ず第2層・第3層に波及させる。
* 第2層：技術上の理由による変更は、第1層に影響しないのが原則。
  ただし、要求の達成可否に関わる場合は第1層にフィードバックし再合意する。
* 第3層：実装中／運用中に発覚した事項は、影響範囲に応じて第2層・第1層に遡って反映する。

### 9.2 ケース別ルール

#### ケースA：第1層の変更・追加

例：

* 新しいユースケース／画面の要望が追加された
* OS互換性要件が変わった

対応：

1. 第1層に REQ-xxxx として追記／変更し、catalog.yaml を更新

2. AIで第2層の機能構成案を再生成（差分付き）

3. アーキテクト／POが第2層の差分をレビュー・承認

4. 影響する機能DocをAIが抽出し、第3層を新規作成／更新

#### ケースB：第2層の変更

例：

* 想定していた技術スタックで要件を満たせないことが判明
* フェーズ構成や機能分割の見直しが必要

対応：

要件自体が変わらない範囲：

1. 第2層の該当箇所（技術スタック／フェーズ／機能一覧）を更新

2. AIで影響範囲の機能Docを洗い出し、必要分を更新

要求の達成可否／品質・コストに大きな影響がある場合：

* 第1層に戻し、PO／業務側と合意形成した上で、第2層を再確定する。

#### ケースC：第3層の変更

例：

* 実装中により良い設計パターンが見つかった
* バグ修正でロジック変更が必要になった

対応：

局所的な修正：

* 機能Docとコード／テストのみ更新

他機能へ影響する／設計レベルの変更：

* 第2層（機能構成・技術方針）にフィードバック

要求自体の見直しが必要なレベル：

* 第1層へ戻り、要件の再定義と合意を取る

#### 補足：軽量運用の目安

* 実装のリファクタリングやバグ修正で、L3の「業務ルール」「入出力」「受け入れ条件」が変わらない場合は、
  L3の「実装メモ」への簡単な追記のみでよい（L2/L1には波及させない）。
* 挙動や仕様が変わる場合（ユーザー視点で見える違いがある場合）は、影響範囲に応じて
  L3 → L2 → L1 の順に遡ってドキュメントを更新する。
* ある程度変更が溜まってから、AI に「この範囲のコード変更に基づいて L3/L2 を見直して」と依頼し、
  まとめて整理し直す運用も許容する。

### 9.3 規模別の運用イメージ

* 個人開発：

  * 軽微な修正（画面レイアウト微調整、文言変更など）は、L3のメモに追記するだけでもよい。
  * REQやフェーズ構成に影響するような変更が出たときに、まとめてL1/L2を更新するスタイルでもよい。
* 小〜中規模チーム：

  * コード変更時に AI に「この PR の変更から見て、影響しそうな L3 / L2 / L1 を教えて」と依頼し、
    影響箇所を優先的に更新する。
  * すべてを即時反映するのではなく、「リリース前に必ず全体整合性チェックを AI で走らせる」タイミングを決めておく。

---

## 10. AI活用ポリシー（役割とレビュー）

### 10.1 AIの主な役割

第1層 → 第2層

* 用語集の抽出
* 機能候補への分解・グルーピング
* フェーズ案の提示
* 非機能カタログ案の起草

第2層 → 第3層

* 機能Docのドラフト生成（概要・タスク・受入条件案・非機能の具体化）

実装／テスト結果 → 上位層

差分検出：

* コード／テストと機能Doc、第2層の不整合候補を検出

修正案の提案：

* どのDocをどう直すべきかの案を提示

全レイヤ横断の整合性チェック

* docs/catalog.yaml と各ドキュメント（L1/L2/L3）の整合性チェック

  * catalogに存在するIDに対応するDocファイルがあるか
  * Doc側のフロントマターの id / kind / layer / status が catalog と一致しているか
  * req_ids / nfr_ids / phase / related_nfr_ids などの参照が有効か
* 孤立したID・切れたリンク・誤った参照の検出
* 検出結果のレポート生成、または修正パッチ案（差分）の提示

実際の運用では、L1→L2変換、L2→L3生成、整合性チェックなどの用途ごとに
標準プロンプト（プロンプトテンプレート）を用意し、プロジェクト内で共有することを想定する。
本ガイド自体は、プロンプトの具体的な中身ではなく、その前提となるドキュメント構造を定義する。

### 10.2 人間によるレビューと doc_status 管理

第2層：

* AIがドラフトを生成 → アーキテクト／BA／テックリードがレビュー・承認

doc_status：

* draft（AIドラフト）
* reviewed（レビュー済み）

第3層：

* AIがドラフトを生成 → 担当開発者／テスターがレビュー・補正
* 実装・テスト完了後、doc_status: implemented として確定

原則：AIが生成した内容は、必ずロールに応じた人間のレビューを経て有効化される。

### 10.3 規模別の運用イメージ

* 個人開発：

  * 最初は「L1→L2」「L2→L3」「catalog整合チェック」の3種類程度のプロンプトから始め、
    必要に応じてカスタマイズしていけばよい。
* 小〜中規模チーム：

  * リポジトリ内に `ai/` ディレクトリを設け、標準プロンプトと利用ルールを共有する。
  * 重要な決定（アーキテクチャ方針など）については、AI提案に対する人間の最終判断を PR やコメントとして残す。

---

## 11. Scrum／バックログ／チケットとの対応付け

### 11.1 アーティファクト対応

| SSDDレイヤ／成果物              | Scrum／PM側の概念例                                  |
| ----------------------- | ---------------------------------------------- |
| 第1層：ビジョン・要求ドキュメント       | プロダクトビジョン／Product Goal／ストーリーマッピング上位レイヤ／Epicの背景 |
| 第2層：機能設計・技術方針・フェーズ・機能一覧 | Product Backlog（Epics/Features/Stories）構造の“正本” |
| 第3層：機能Doc               | 各Story/Taskの仕様＋受け入れ条件の詳細、テスト観点の集約              |

チケットツール（例：Jira）では、以下の運用を想定する。

* 第2層の機能ID（F-xxxx）をキーとして Story/Task を起こす。
* チケットから対応する L3 機能Docへのリンク／添付を行う。

補足：チケットツール側の説明・コメントはあくまでビューとし、
要件・設計・仕様の正本は Git リポジトリ内の L1〜L3 ドキュメントおよび catalog.yaml に置く。

### 11.2 1スプリントの典型的な流れ（SSDD適用時）

1. スプリント前のバックログリファインメント

   * 第2層を参照し、実装候補フェーズ／機能を確認
   * AIで対象機能の機能Docドラフトを生成

2. スプリントプランニング

   * 機能DocドラフトをもとにStory/Taskを見積り
   * スプリント内で完了を目指す機能Doc（F-xxxx）を選定

3. スプリント中

   * 開発者は機能Docを参照しつつ実装・テストを行う
   * 完了後、機能Docの doc_status を implemented に更新

4. スプリント終盤〜フェーズ境界

   * 対象フェーズが完了条件を満たすタイミングで、結合テスト／E2Eテストを実施

5. スプリントレビュー

   * 第1層のビジョン／要求に対して、完了した機能がどのように貢献したかを説明

6. レトロスペクティブ

   * SSDD運用（AI出力品質、ドキュメント鮮度、更新コスト）について振り返る

---

## 12. 開発フロー（時系列まとめ）

1. L1 にビジョン・要求（REQ-xxxx）を書く（doc_status: draft → reviewed）

2. catalog.yaml に REQ を登録

3. AIで L1 → L2 のドラフトを生成（用語集／PH／F／NF）

4. L2 をレビューし、catalog.yaml に PH / F / NF を登録（doc_status: reviewed）

5. スプリントで実装する F-xxxx を選び、L3 機能DocをAIでドラフト生成

6. L3 ドラフトをレビュー・補正し、doc_status: reviewed

7. 実装・テストを行い、L3・コード・テストを同期（doc_status: implemented）

8. フェーズ境界で AI 生成テストシナリオ＋結合／E2Eテストを実施

9. 結果を L3 → L2 → L1 に必要に応じてフィードバック

10. L1 や L2 の変更があれば、catalog.yaml と各レイヤを前述のルールに従って更新

11. 適宜、AIによる「全ドキュメント整合性チェック」を実行し、ID不整合やリンク切れを解消する

---

## 13. 適用範囲とライト版運用

### 13.1 SSDDフル版が有効なケース

* ドメイン／業務ロジックが複雑で、要件ドキュメントが大きくなりがち
* 今後も要求変更が継続することが見込まれる
* AIツールの利用が許容されており、LLMに要件・コードを読ませられる環境がある

### 13.2 ライト版運用の例

小規模・短期案件では、以下のような簡略版も許容する。

* 第1層＋第3層のみ（第2層は軽量な技術メモ＋簡易機能一覧）
* フェーズを定義せず、スプリント単位で結合テストを行う
* 非機能カタログ（NF）を最小限に絞る

その場合でも、

* 第1層が要件の正本
* 技術方針・機能構成の正は簡略版第2層に置く

というソース・オブ・トゥルースの考え方は維持する。

### 13.3 規模別の導入ステップ（例）

* Step1：L1 と L3 のみを導入し、「L3 を AI に渡してコードを書く」運用から始める。
* Step2：L2 にフェーズ（PH）と機能一覧（F）を追加し、L1→L2→L3 のパスを AI に張らせる。
* Step3：catalog.yaml を整備し、AI による整合性チェックを時々走らせる。

---

## 14. まとめ

本ガイドでは、SSDDサイクルにおけるドキュメント運用と開発フローを

* 第1層：ビジョン・要求の正本（L1）
* 第2層：機能構成・技術方針・フェーズ・非機能カタログの正本（L2）
* 第3層：機能単位の実装・テストの解説ビュー（L3）

という三層構造として定義し、

* ソース・オブ・トゥルースと変更伝播ルール
* フェーズと結合テスト／E2Eテスト、AIによるシナリオ生成
* AI活用の具体的な役割（生成・差分検出・全ドキュメント整合性チェック）とレビュー・ステータス（doc_status）
* Scrum／バックログ／チケットとの対応付け
* Git＋コードエージェント／catalog.yaml による実装前提
* 規模別の運用イメージとライト版運用

までを整理した。

今後は、本ガイドに基づき

* 実プロジェクトでの試行（PoC）
* 各レイヤのテンプレート具体化（L1／L2／L3）
* catalog.yaml 構造と AI プロンプトのチューニング
* 運用実績に基づく改善（SSDD 自体のレトロスペクティブ）

を通じて、SSDDサイクルを「開発者とAIエージェントの共創」に適した運用フレームとして継続的に洗練させていく。
