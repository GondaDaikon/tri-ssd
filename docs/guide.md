# SSDD 概念ガイド

## 1. 三層モデル（L1/L2/L3）

### 1.1 三層構造の概要

SSDD におけるドキュメントは、次の三層で構成されます。

| 層 | 名称 | 役割 |
|----|------|------|
| L1 | ビジョン・要求ドキュメント | ビジネス要求・背景・制約・願望ベースの機能／画面イメージを記録 |
| L2 | 機能設計・技術方針ドキュメント | 要求を満たすための機能構成・技術スタック・フェーズ・非機能カタログを構造化 |
| L3 | 機能ドキュメント | 各機能ごとのミニ仕様＋タスク＋テスト＋実装メモを記録 |

### 1.2 AIの主な支援範囲

LLM／AIコードエージェントは主に以下を支援します：

- **L1 → L2**: 要求の構造化（用語集抽出、機能分解、フェーズ案提示）
- **L2 → L3**: 機能Docのドラフト生成
- **実装結果 → 上位層**: 差分検出・修正案提示

### 1.3 ソース・オブ・トゥルースの考え方

各レイヤの「何についての正本か」を明確にします。

| 層 | 正本の対象 |
|----|-----------|
| L1 | 要件（ビジネス要求・ユーザ要求・制約条件） |
| L2 | 設計判断（機能構成・依存・フェーズ・技術スタック・非機能カタログ） |
| L3 | 実装・テストの解説ビュー |
| コード＋テスト | 実装された挙動の最終的な正 |

> L3 は、コードとテストを読み解く前の入口となる「実装・テストの解説ビュー」です。
> AI にとっても、人間にとっても、コードを直接読む前に参照するビューとして機能します。

---

## 2. Git リポジトリ構成と ID 管理

### 2.1 管理方針

- ソースコードと同一 Git リポジトリ内に L1〜L3 を格納
- ブランチ／タグ／Pull Request により、コードと同じフローで変更管理・レビューを実施
- **ID管理はフロントマターを正本とし、catalog.yaml による二重管理は行わない**

> ID一覧が必要な場合は `/check --list-ids` で動的生成します。

### 2.2 ディレクトリ構成（例）

```text
docs/
  l1_vision/
    vision.md
  l2_system/
    overview.md          # 用語集・技術方針・全体構成
    phases.md            # フェーズ定義（PH-xxxx）＋各フェーズ配下の機能一覧
    nfr.md               # 非機能要求カタログ（NF-xxxx）
    features_index.md    # 機能一覧（F-xxxx）テーブル（全体の俯瞰用）
  l3_features/
    F-0001_markdown-edit.md
    F-0002_multi-tab.md
    ...
src/
  ...
```

### 2.3 ID 種類

| ID形式 | 用途 |
|--------|------|
| REQ-xxxx | 要件 |
| PH-xxxx | フェーズ |
| PH-POC-xxxx | 検証フェーズ |
| NF-xxxx | 非機能要求 |
| F-xxxx | 機能（Feature） |
| SP-xxxx | スパイク／PoC（任意） |

### 2.4 規模別の運用イメージ

**個人開発：**
- 整合性チェックは、リリース前や区切りのタイミングで AI に依頼する運用で十分

**小〜中規模チーム：**
- レビュー時に AI で整合性チェックを走らせることを推奨
- ID が増えて管理が重くなってきた場合は、REQ / F / NF / PH ごとにファイル分割を検討

---

## 3. 第1層（L1）：ビジョン・要求ドキュメント

### 3.1 目的・役割

- プロダクトの目的・背景・制約・ビジネス要求・ユーザ要求を自然言語で記述
- L2 が何度でも「解釈し直せる材料」を提供
- 技術的な詳細ではなく、「何のために・誰のために・どう使われるべきか」を表現

> L1 は、ラフなメモや箇条書きから AI にドラフトを生成させ、PO／業務担当／開発者が読みながら修正していく運用を想定します。

### 3.2 想定読者

- PO／業務担当／UX
- アーキテクト／テックリード
- ステークホルダー全般

### 3.3 記載しないもの

- クラス設計、API仕様、DBスキーマ等の具体的な技術設計
- 実装タスクの細かい分割
- ソースコード断片

### 3.4 ID付与の基本ルール

- 要件には一意なIDを付与：REQ-0001, REQ-0002, …
- 類似要件のグルーピングは L2 側の責務（L1側は「書きやすさ」を優先）
- REQ ID の採番や命名は、AI に依頼して自動付与させてもよい

### 3.5 規模別の運用イメージ

**個人開発：**
- L1 は `vision.md` 1ファイルに集約し、「課題・ペルソナ・願望リスト・高レベル非機能」をラフに書き出すだけでもよい
- REQ の詳細な説明は、必要になってから AI に整形を依頼

**小〜中規模チーム：**
- L1 を「ビジョン（背景・目的）」と「要求一覧（REQ-xxxx）」で章分けして管理
- 要求一覧はフロントマターの参照フィールド（req_ids）でトレーサビリティを確保

---

## 4. 第2層（L2）：機能設計・技術方針ドキュメント

### 4.1 目的・役割

- L1 の要求を満たすための機能構成・技術スタック・フェーズ・非機能カタログを体系的に定義
- バックログ／機能Doc／テスト計画の元データとなる「システム側のモデル」
- 要求を「実装しうる形」に落とし込む責任を持つ

> L1 からの変換は、AI による「L1→L2ドラフト生成」を基本とし、アーキテクト／テックリードがレビュー・修正して確定させます。

### 4.2 想定読者

- アーキテクト／テックリード／BA
- 開発者／テスター
- 一部 PO（全体像把握用）

### 4.3 フェーズ定義（Phase設計）

フェーズ（PH-xxxx）は、「結合して動かしたときに意味のある機能群」を束ねたマイルストーン単位です。

各フェーズについて定義する項目：

- **Phase ID**: PH-0001, PH-0002, …
- **名称**: 例「基盤Skeleton」「基本編集機能」
- **目的**: ユーザ視点・アーキテクチャ視点での完了イメージ
- **適用される主な非機能（NF-xxxx）**
- **フェーズ完了条件（Exit Criteria）**
- **フェーズ境界で実施するテストの種類と概要**

#### フェーズ配下の機能一覧

各フェーズごとに「そのフェーズの対象機能一覧」を記載します。
**記載順序＝実装順序** とみなし、別フィールドに「実装順」カラムは持ちません。

#### 検証フェーズ（PH-POC）

技術的・非機能的な不確実性が高い領域については、通常の機能フェーズとは別に「検証フェーズ（PH-POC-xxxx）」を定義します。

- 対象は F-xxxx ではなく SP-xxxx（スパイク／PoC）として管理
- 本番コードへの直接取り込みを前提としない実験コードを含んでもよい
- 完了条件は「OK/NGの結論＋L2への反映」

### 4.4 機能一覧（全体俯瞰用）

全体を俯瞰するためのテーブルとして定義し、実装順序は持ちません。

| 項目 | 内容 |
|------|------|
| 機能ID | F-0001, F-0002, … |
| 機能名 | |
| 対応する REQ ID | 複数可 |
| 所属フェーズ | PH-xxxx |
| 依存関係 | 他のF-xxxx |
| ステータス | 未着手／実装中／実装済み 等 |

### 4.5 非機能要求カタログ（NF-xxxx）

各NFの内容：

- **ID／名称**
- **説明**: 何を満たす必要があるか
- **適用範囲**: どの機能／フェーズに適用されるか
- **テスト／監視方法へのリンク**

### 4.6 規模別の運用イメージ

**個人開発：**
- PH-0001〜0003 程度の粗いフェーズだけ決め、F-xxxx の並び順を「実装予定順」として管理する程度でもよい

**小〜中規模チーム：**
- バックログリファインメント時に、対象フェーズと F-xxxx を確認し、AIに優先度順の並べ替えを提案させる
- 技術スタックや主要設計判断は L2 に集約し、詳細設計・実装メモは L3 に降ろす

---

## 5. 第3層（L3）：機能ドキュメント

### 5.1 目的・役割

- L2 の機能一覧から切り出し、1機能ごとに実装・テストを行うためのミニ仕様
- 実装前は「仕様＋タスク＋受入条件」、実装後は「どう実装したかのサマリ＋コードへの入口」
- そのままコードエージェントに渡すことで、実装コードやテストコードのドラフト生成に利用

> L3 も、基本は AI がドラフトを書き、担当開発者／テスターがレビュー・補正します。

### 5.2 想定読者

- 開発者／テスター
- コードレビュー担当者

### 5.3 規模別の運用イメージ

**個人開発：**
- L3 は、実装前に AI にドラフトを書かせ、「概要」「入出力」「簡単なテスト観点」だけ埋まっていればよい
- 実装後に、「実装メモ」に気づきや注意点を1〜2行追記するくらいの軽い運用で構わない

**小〜中規模チーム：**
- L3 のタスクチェックリストや受け入れ条件を、レビューやテスト設計の材料として使う
- バグ修正や仕様変更時には、L3 に一行でも「何が変わったか」を追記し、AI の差分検出に活かす

> 注：L3 はあくまで「コード＋テストを理解するためのビュー」であり、最終的な挙動の正しさはコード＋テストに委ねます。

---

## 6. ソース・オブ・トゥルースと変更伝播ルール

### 6.1 原則

- **L1**: 要件の変更・追加は必ず L2・L3 に波及させる
- **L2**: 技術上の理由による変更は、L1 に影響しないのが原則。ただし、要求の達成可否に関わる場合は L1 にフィードバックし再合意する
- **L3**: 実装中／運用中に発覚した事項は、影響範囲に応じて L2・L1 に遡って反映する

### 6.2 ケース別ルール

#### ケースA：L1 の変更・追加

**例：**
- 新しいユースケース／画面の要望が追加された
- OS互換性要件が変わった

**対応：**
1. L1 に REQ-xxxx として追記／変更し、フロントマターに記載
2. AI で L2 の機能構成案を再生成（差分付き）
3. アーキテクト／PO が L2 の差分をレビュー・承認
4. 影響する機能Doc を AI が抽出し、L3 を新規作成／更新

#### ケースB：L2 の変更

**例：**
- 想定していた技術スタックで要件を満たせないことが判明
- フェーズ構成や機能分割の見直しが必要

**対応（要件自体が変わらない範囲）：**
1. L2 の該当箇所（技術スタック／フェーズ／機能一覧）を更新
2. AI で影響範囲の機能Doc を洗い出し、必要分を更新

**対応（要求の達成可否／品質・コストに大きな影響がある場合）：**
- L1 に戻し、PO／業務側と合意形成した上で、L2 を再確定する

#### ケースC：L3 の変更

**例：**
- 実装中により良い設計パターンが見つかった
- バグ修正でロジック変更が必要になった

**対応（局所的な修正）：**
- 機能Doc とコード／テストのみ更新

**対応（他機能へ影響する／設計レベルの変更）：**
- L2（機能構成・技術方針）にフィードバック

**対応（要求自体の見直しが必要なレベル）：**
- L1 へ戻り、要件の再定義と合意を取る

### 6.3 軽量運用の目安

- 実装のリファクタリングやバグ修正で、L3 の「業務ルール」「入出力」「受け入れ条件」が変わらない場合は、L3 の「実装メモ」への簡単な追記のみでよい（L2/L1 には波及させない）
- 挙動や仕様が変わる場合（ユーザー視点で見える違いがある場合）は、影響範囲に応じて L3 → L2 → L1 の順に遡ってドキュメントを更新する
- ある程度変更が溜まってから、AI に「この範囲のコード変更に基づいて L3/L2 を見直して」と依頼し、まとめて整理し直す運用も許容する

### 6.4 規模別の運用イメージ

**個人開発：**
- 軽微な修正（画面レイアウト微調整、文言変更など）は、L3 のメモに追記するだけでもよい
- REQ やフェーズ構成に影響するような変更が出たときに、まとめて L1/L2 を更新するスタイルでもよい

**小〜中規模チーム：**
- コード変更時に AI に「この PR の変更から見て、影響しそうな L3 / L2 / L1 を教えて」と依頼し、影響箇所を優先的に更新する
- すべてを即時反映するのではなく、「リリース前に必ず全体整合性チェックを AI で走らせる」タイミングを決めておく

---

## 7. AI活用ポリシー

### 7.1 AIの主な役割

#### L1 → L2

- 用語集の抽出
- 機能候補への分解・グルーピング
- フェーズ案の提示
- 非機能カタログ案の起草

#### L2 → L3

- 機能Doc のドラフト生成（概要・タスク・受入条件案・非機能の具体化）

#### 実装／テスト結果 → 上位層

- **差分検出**: コード／テストと機能Doc、L2 の不整合候補を検出
- **修正案の提案**: どの Doc をどう直すべきかの案を提示

#### 全レイヤ横断の整合性チェック

- 各ドキュメントのフロントマター（id / kind / layer / status）の整合性チェック
- req_ids / nfr_ids / phase / related_nfr_ids などの参照が有効かの検証
- 孤立したID・切れたリンク・誤った参照の検出
- 検出結果のレポート生成、または修正パッチ案（差分）の提示

> 実際の運用では、L1→L2変換、L2→L3生成、整合性チェックなどの用途ごとに標準プロンプト（プロンプトテンプレート）を用意し、プロジェクト内で共有することを想定します。

### 7.2 人間によるレビューと doc_status 管理

**L2：**
- AI がドラフトを生成 → アーキテクト／BA／テックリードがレビュー・承認
- doc_status: draft（AIドラフト）→ reviewed（レビュー済み）

**L3：**
- AI がドラフトを生成 → 担当開発者／テスターがレビュー・補正
- 実装・テスト完了後、doc_status: implemented として確定

> **原則**: AI が生成した内容は、必ずロールに応じた人間のレビューを経て有効化されます。

### 7.3 規模別の運用イメージ

**個人開発：**
- 最初は「L1→L2」「L2→L3」「整合チェック」の3種類程度のプロンプトから始め、必要に応じてカスタマイズしていく

**小〜中規模チーム：**
- リポジトリ内に `ai/` ディレクトリを設け、標準プロンプトと利用ルールを共有する
- 重要な決定（アーキテクチャ方針など）については、AI提案に対する人間の最終判断を PR やコメントとして残す
