# SSDD 概念ガイド

> **バージョン**: v0.5
> **対象範囲**: SSDD の概念・設計方針・三層モデルの解説

## 主要な設計方針

SSDD では、実運用での課題を解決する以下の設計方針を採用しています：

### 変更1: ID管理方式の変更
**問題**: 連番方式（REQ-0001, F-0001）では並行開発時にID衝突が発生
**解決**: タイムスタンプベース方式（REQ-20250125-001, F-20250125-001）を採用

### 変更2: フロントマター仕様の変更
**問題**: `title`フィールドとMarkdown見出しの同期問題
**解決**: `title`フィールドを廃止、本文の`# 見出し`をタイトルとして扱う

### 変更3: L2構成のシンプル化
**問題**: 4ファイル構成（overview, phases, nfr, features_index）は小規模開発に過剰
**解決**: 2ファイル構成（overview, phases）をデフォルトに変更

### 変更4: 技術選定プロセスの変更
**問題**: AI自動選定では不適切な技術が選ばれるリスク
**解決**: AIが候補提示 → ユーザーとの対話を通じて人間が選択

詳細は本ドキュメント各セクションおよび`docs/frontmatter_spec.md`を参照。

---

## 1. 三層モデル（L1/L2/L3）

### 1.1 三層構造の概要

SSDD におけるドキュメントは、次の三層で構成されます。

| 層 | 名称 | 役割 |
|----|------|------|
| L1 | ビジョン・要求ドキュメント | ビジネス要求・背景・制約・願望ベースの機能／画面イメージを記録 |
| L2 | 機能設計・技術方針ドキュメント | 要求を満たすための機能構成・技術スタック・フェーズ・非機能カタログを構造化 |
| L3 | 機能ドキュメント | 各機能ごとのミニ仕様＋タスク＋テスト＋実装メモを記録 |

### 1.2 AIの主な支援範囲

LLM／AIコードエージェントは主に以下を支援します：

- **L1 → L2**: 要求の構造化（用語集抽出、機能分解、フェーズ案提示）
- **L2 → L3**: 機能Docのドラフト生成
- **実装結果 → 上位層**: 差分検出・修正案提示

### 1.3 ソース・オブ・トゥルースの考え方

各レイヤの「何についての正本か」を明確にします。

| 層 | 正本の対象 |
|----|-----------|
| L1 | 要件（ビジネス要求・ユーザ要求・制約条件） |
| L2 | 設計判断（機能構成・依存・フェーズ・技術スタック・非機能カタログ） |
| L3 | **機能単位の仕様・設計意図**（AIコード生成の入力として機能） |
| コード＋テスト | 実装された挙動の最終的な正 |

### 1.4 L3の設計思想：分割統治によるAI活用

SSDDの核心は、**複雑な要件を機能単位に分割し、AIが扱える粒度に統治する**ことにあります。

#### なぜ分割統治が必要か

AIコードエージェント（および人間の開発者）には、一度に扱える複雑さに限界があります：

- **複雑なシステム全体**を一度にコード生成することは困難
- **機能単位に分割**することで、AIが精度高くコード・テストを生成できる
- L3は「AIとのフィードバックサイクルを回す作業単位」として機能

#### L3を中心としたフィードバックサイクル

```
┌─────────────────────────────────────────────────────┐
│                    L3 機能ドキュメント                │
│  ・概要・入出力・業務ルール・受け入れ条件              │
└─────────────────┬───────────────────────────────────┘
                  ↓ AIがコード・テスト生成
┌─────────────────────────────────────────────────────┐
│                 コード＋テスト                        │
└─────────────────┬───────────────────────────────────┘
                  ↓ 実行・検証
┌─────────────────────────────────────────────────────┐
│              テスト結果・エラー・改善点                │
└─────────────────┬───────────────────────────────────┘
                  ↓ L3を更新（実装メモ・知見追記）
                  ↓ 必要に応じて再生成
              （サイクルを繰り返す）
```

#### L3の役割の明確化

| フェーズ | L3の役割 |
|---------|---------|
| **実装前** | AIへの入力仕様書。概要・入出力・受け入れ条件を定義 |
| **実装中** | フィードバックサイクルの中心。AIの生成結果を評価し、L3を更新しながら精度を上げる |
| **実装後** | 設計意図・判断理由の記録。コードを読む前の「なぜこう実装したか」の入口 |

> **重要**: 実装後も L3 は「陳腐化してよいドキュメント」ではありません。
> 設計意図・背景・重要な判断理由は L3 に残し、コードだけでは分からない文脈を保持します。
> ただし、実装の詳細（関数名・引数の型など）はコードが正であり、L3 との完全同期は求めません。

---

## 2. Git リポジトリ構成と ID 管理

### 2.1 管理方針

- ソースコードと同一 Git リポジトリ内に L1〜L3 を格納
- ブランチ／タグ／Pull Request により、コードと同じフローで変更管理・レビューを実施
- **ID管理はフロントマターを正本とし、catalog.yaml による二重管理は行わない**

> ID一覧が必要な場合は `/check --list-ids` で動的生成します。

### 2.2 ディレクトリ構成（例）

```text
docs/
  l1_vision.md
  l2_system/
    overview.md          # 用語集・技術方針・全体構成・NFRカタログ
    phases.md            # フェーズ定義（PH-YYYYMMDD-nnn）＋各フェーズ配下の機能一覧
  l3_features/
    F-20250125-001_markdown-edit.md
    F-20250125-002_multi-tab.md
    ...
src/
  ...
```

**v0.1変更点**:
- L2は2ファイル構成がデフォルト（nfr.md, features_index.mdはoverviewとphasesに統合）
- IDはタイムスタンプベース形式（F-20250125-001）を使用

### 2.3 ID 種類

| ID形式 | 用途 |
|--------|------|
| VISION-YYYYMMDD-nnn | L1ビジョンドキュメント |
| REQ-YYYYMMDD-nnn | 要件 |
| L2-YYYYMMDD-nnn | L2概要（省略可） |
| PH-YYYYMMDD-nnn | フェーズ |
| PH-POC-YYYYMMDD-nnn | 検証フェーズ |
| NF-YYYYMMDD-nnn | 非機能要求 |
| F-YYYYMMDD-nnn | 機能（Feature） |
| SP-YYYYMMDD-nnn | スパイク／PoC（任意） |

#### 2.3.1 ID 採番ルール（v0.1以降）

**タイムスタンプベースID:**

形式: `{PREFIX}-YYYYMMDD-nnn`

**採番例:**
```
REQ-20250125-001  # 2025年1月25日の最初の要件
REQ-20250125-002  # 同日の2番目の要件
REQ-20250126-001  # 翌日の最初の要件
F-20250125-001    # 2025年1月25日の最初の機能
F-20250125-002    # 同日の2番目の機能
NF-20250125-001   # 2025年1月25日の最初の非機能要求
PH-20250125-001   # 2025年1月25日の最初のフェーズ
```

**利点:**
- 並行開発時のID衝突を防止
- タイムスタンプで作成日が分かる
- 分散チームでも安全

**日付とタイムゾーンについて:**
- 日付部分（YYYYMMDD）は**ローカル日付**を使用
- グローバルチームの場合は、チーム内で基準タイムゾーンを統一することを推奨（例: JST、UTC）
- 異なるタイムゾーンで同日に採番しても、連番部分（nnn）で区別されるため衝突しにくい

**連番の上限:**
- 連番部分（nnn）は 001〜999 の3桁で、1日あたり最大999件まで採番可能
- 通常の開発では十分な上限だが、大量の一括生成を行う場合は日付をまたぐか、4桁（nnnn）への拡張を検討

**各種類のIDは独立して採番:**
- REQ-20250125-001, F-20250125-001, NF-20250125-001は別々に存在可
- `/draft-l1`, `/gen-l2`, `/gen-l3` コマンドが自動採番

**欠番の扱い:**
- 削除したIDの欠番は埋めない（歴史的記録として残す）
- 例: REQ-20250125-002を削除しても、次はREQ-20250125-003とする

**手動採番時の注意:**
- 既存IDとの重複を避けるため、`/check --list-ids` で確認
- 当日の連番を守ることで、時系列が把握しやすくなる

**v1.x（連番方式）からの移行:**
- 既存IDはそのまま維持（REQ-0001などは変更不要）
- 新規IDのみv0.1形式を使用することを推奨

### 2.4 規模別の運用イメージ

**個人開発：**
- 整合性チェックは、リリース前や区切りのタイミングで AI に依頼する運用で十分

**小〜中規模チーム：**
- レビュー時に AI で整合性チェックを走らせることを推奨
- ID が増えて管理が重くなってきた場合は、REQ / F / NF / PH ごとにファイル分割を検討

### 2.5 doc_status 遷移ルール

`doc_status` フィールドは、ドキュメントの成熟度を表します。

#### 2.5.1 基本的な遷移フロー

```
draft → reviewed → implemented
```

| 状態 | 説明 | 遷移条件 |
|------|------|---------|
| **draft** | AIドラフトまたは書きかけ | - AI生成直後<br>- 人間がざっくり書いた直後 |
| **reviewed** | レビュー済み、実装・運用可能 | - 内容を確認し、実装に使えるレベルと判断<br>- L1/L2: ステークホルダー承認済み<br>- L3: 技術的妥当性を確認済み |
| **implemented** | 実装・テスト完了、ドキュメント追従済み | - 実装とテストが完了<br>- ドキュメントも実装結果に追随済み<br>- **主にL3で使用** |

#### 2.5.2 規模別の運用ガイド

**個人開発：**
- `draft`: AI生成直後
- `reviewed`: 自分で読み直して「一旦これで進める」と判断
- `implemented`: 実装とテストを終えて内容をざっくり追随

**小〜中規模チーム：**
- `reviewed` への遷移時、レビュアーを記録（PR コメント or Git commit message）
- 重要な設計（L2等）は、特定ロール（アーキテクト等）のレビューを必須化
- L3 の `implemented` は、実装PR承認時に同時更新

#### 2.5.3 status: removed ファイルの扱い

`status: removed` のドキュメントは以下のように扱います：

- **推奨**: Git履歴があるため物理削除する
- **例外**: 歴史的価値がある場合は `archive/` ディレクトリに移動
- `/check` コマンドで `status: removed` を検出した場合、削除を推奨

---

## 3. 第1層（L1）：ビジョン・要求ドキュメント

### 3.1 目的・役割

- プロダクトの目的・背景・制約・ビジネス要求・ユーザ要求を自然言語で記述
- L2 が何度でも「解釈し直せる材料」を提供
- 技術的な詳細ではなく、「何のために・誰のために・どう使われるべきか」を表現

> L1 は、ラフなメモや箇条書きから AI にドラフトを生成させ、PO／業務担当／開発者が読みながら修正していく運用を想定します。

### 3.2 想定読者

- PO／業務担当／UX
- アーキテクト／テックリード
- ステークホルダー全般

### 3.3 記載しないもの

- クラス設計、API仕様、DBスキーマ等の具体的な技術設計
- 実装タスクの細かい分割
- ソースコード断片

### 3.4 ID付与の基本ルール

- 要件には一意なIDを付与：REQ-20250125-001, REQ-20250125-002, …
- 類似要件のグルーピングは L2 側の責務（L1側は「書きやすさ」を優先）
- REQ ID の採番や命名は、AI に依頼して自動付与させてもよい

### 3.5 規模別の運用イメージ

**個人開発：**
- L1 は `vision.md` 1ファイルに集約し、「課題・ペルソナ・願望リスト・高レベル非機能」をラフに書き出すだけでもよい
- REQ の詳細な説明は、必要になってから AI に整形を依頼
- 要件は箇条書きでもOK（フロントマターとID管理は標準に従う）

**小〜中規模チーム：**
- L1 を「ビジョン（背景・目的）」と「要求一覧（REQ-YYYYMMDD-nnn）」で章分けして管理
- 要求一覧はフロントマターの参照フィールド（req_ids）でトレーサビリティを確保

> **v0.4変更**: 「ライト版運用」の概念は廃止されました。小規模プロジェクトでも標準SSDDを採用し、段階的に導入することを推奨します。詳細は`docs/checklists.md`の「v0.4変更点: ライト版の廃止」を参照してください。

---

## 4. 第2層（L2）：機能設計・技術方針ドキュメント

### 4.1 目的・役割

- L1 の要求を満たすための機能構成・技術スタック・フェーズ・非機能カタログを体系的に定義
- バックログ／機能Doc／テスト計画の元データとなる「システム側のモデル」
- 要求を「実装しうる形」に落とし込む責任を持つ

> L1 からの変換は、AI による「L1→L2ドラフト生成」を基本とし、アーキテクト／テックリードがレビュー・修正して確定させます。

### 4.2 想定読者

- アーキテクト／テックリード／BA
- 開発者／テスター
- 一部 PO（全体像把握用）

### 4.3 フェーズ定義（Phase設計）

フェーズ（PH-YYYYMMDD-nnn）は、「結合して動かしたときに意味のある機能群」を束ねたマイルストーン単位です。

各フェーズについて定義する項目：

- **Phase ID**: PH-20250125-001, PH-20250125-002, …
- **名称**: 例「基盤Skeleton」「基本編集機能」
- **目的**: ユーザ視点・アーキテクチャ視点での完了イメージ
- **適用される主な非機能（NF-YYYYMMDD-nnn）**
- **フェーズ完了条件（Exit Criteria）**
- **フェーズ境界で実施するテストの種類と概要**

#### フェーズ配下の機能一覧

各フェーズごとに「そのフェーズの対象機能一覧」を記載します。
**記載順序＝実装順序** とみなし、別フィールドに「実装順」カラムは持ちません。

#### 検証フェーズ（PH-POC）

技術的・非機能的な不確実性が高い領域については、通常の機能フェーズとは別に「検証フェーズ（PH-POC-YYYYMMDD-nnn）」を定義します。

- 対象は F-YYYYMMDD-nnn ではなく SP-YYYYMMDD-nnn（スパイク／PoC）として管理
- 本番コードへの直接取り込みを前提としない実験コードを含んでもよい
- 完了条件は「OK/NGの結論＋L2への反映」

#### フェーズとイテレーションの関係（v0.3明確化）

**フェーズ（Phase）**と**イテレーション（Sprint/Iteration）**は異なる概念です：

| 項目 | フェーズ | イテレーション |
|------|---------|--------------|
| **定義** | 機能的なマイルストーン | 時間的なマイルストーン |
| **単位** | 「意味のある機能群」 | 「固定期間（1-4週間）」 |
| **完了条件** | Exit Criteria（機能完成＋テスト） | 時間経過 |
| **関係** | 1フェーズ = 1〜複数イテレーション | 1イテレーション = 1フェーズの一部 |
| **管理主体** | アーキテクト／テックリード | スクラムマスター／PM |

**例**:
```
フェーズ1「基盤構築」（2週間）
  ├─ イテレーション1（1週間）: 認証基盤実装
  └─ イテレーション2（1週間）: データベース基盤実装

フェーズ2「コア機能」（4週間）
  ├─ イテレーション3（2週間）: ユーザー管理
  └─ イテレーション4（2週間）: コンテンツ管理
```

**運用方針**:
- **SSDDではフェーズを定義**: L2でフェーズ（PH-YYYYMMDD-nnn）を管理
- **イテレーション計画は別管理**: Jira/GitHub Projects等のタスク管理ツールで管理
- **柔軟な対応**: 1フェーズが複数イテレーションにまたがることも、1イテレーションで複数フェーズを完了することも許容

**判断基準**:
- フェーズ完了 = Exit Criteriaをすべて満たした（機能完成＋結合テスト完了）
- イテレーション完了 = 期間終了（フェーズ未完了でも次イテレーションへ）

### 4.4 機能一覧（全体俯瞰用）

全体を俯瞰するためのテーブルとして定義し、実装順序は持ちません。

| 項目 | 内容 |
|------|------|
| 機能ID | F-20250125-001, F-20250125-002, … |
| 機能名 | |
| 対応する REQ ID | 複数可 |
| 所属フェーズ | PH-YYYYMMDD-nnn |
| 依存関係 | 他のF-YYYYMMDD-nnn |
| ステータス | 未着手／実装中／実装済み 等 |

**v0.1変更点**: features_index.mdは廃止され、phases.md内に統合されました。

### 4.5 非機能要求カタログ（NF-YYYYMMDD-nnn）

各NFの内容：

- **ID／名称**: NF-20250125-001, NF-20250125-002, …
- **説明**: 何を満たす必要があるか
- **適用範囲**: どの機能／フェーズに適用されるか
- **テスト／監視方法へのリンク**

**v0.1変更点**: nfr.mdは廃止され、overview.md内に統合されました。

### 4.6 規模別の運用イメージ

**個人開発：**
- PH-20250125-001〜003 程度の粗いフェーズだけ決め、F-YYYYMMDD-nnn の並び順を「実装予定順」として管理する程度でもよい

**小〜中規模チーム：**
- バックログリファインメント時に、対象フェーズと F-YYYYMMDD-nnn を確認し、AIに優先度順の並べ替えを提案させる
- 技術スタックや主要設計判断は L2 に集約し、詳細設計・実装メモは L3 に降ろす

---

## 5. 第3層（L3）：機能ドキュメント

### 5.1 目的・役割

- L2 の機能一覧から切り出し、1機能ごとに実装・テストを行うためのミニ仕様
- 実装前は「仕様＋タスク＋受入条件」、実装後は「どう実装したかのサマリ＋コードへの入口」
- そのままコードエージェントに渡すことで、実装コードやテストコードのドラフト生成に利用

> L3 も、基本は AI がドラフトを書き、担当開発者／テスターがレビュー・補正します。

### 5.2 想定読者

- 開発者／テスター
- コードレビュー担当者

### 5.3 規模別の運用イメージ

**個人開発：**
- L3 は、実装前に AI にドラフトを書かせ、「概要」「入出力」「簡単なテスト観点」だけ埋まっていればよい
- 実装後に、「実装メモ」に気づきや注意点を1〜2行追記するくらいの軽い運用で構わない

**小〜中規模チーム：**
- L3 のタスクチェックリストや受け入れ条件を、レビューやテスト設計の材料として使う
- バグ修正や仕様変更時には、L3 に一行でも「何が変わったか」を追記し、AI の差分検出に活かす

> 注：L3 はあくまで「コード＋テストを理解するためのビュー」であり、最終的な挙動の正しさはコード＋テストに委ねます。

### 5.4 L3軽量運用ガイドライン

L3は**省略せず、最低限の情報を記載**してください。これがAIコード生成の入力となり、フィードバックサイクルの基点になります。

#### なぜL3を省略しないか

| 観点 | 理由 |
|------|------|
| **分割統治** | L3は「AIとのフィードバックサイクルを回す作業単位」。省略するとサイクルが成り立たない |
| **トレーサビリティ** | L3がないとREQ→F→コードの追跡が困難 |
| **AIコード生成** | L3仕様がないと、AIは何を基準にコードを生成すべきか不明 |

#### 最低限のL3（軽量版）

シンプルな機能であっても、以下の最低限の情報は記載してください：

```markdown
---
id: F-YYYYMMDD-nnn
kind: feature
layer: L3
status: active
doc_status: draft
req_ids: [REQ-YYYYMMDD-nnn]
phase: PH-YYYYMMDD-nnn
---

# 機能名

## 概要
1-2行の説明

## 入出力
- 入力: xxx
- 出力: xxx

## 受け入れ条件
- AC-001: xxxができる
```

#### 省略可能なセクション

以下のセクションは、シンプルな機能では省略または簡素化できます：

| セクション | 省略条件 |
|-----------|---------|
| タスクチェックリスト | AIが実装時に自動生成するため、事前記載は任意 |
| 実装メモ | 実装後に追記。実装前は空でよい |
| 詳細な業務ルール | 受け入れ条件で表現できる場合は省略可 |
| 非機能要求の具体化 | NFRカタログで十分な場合は省略可 |

> **重要**: L3を「省略する」のではなく「軽量に書く」という考え方です。フロントマター＋概要＋入出力＋受け入れ条件があれば、AIは十分にコード生成できます。

---

## 6. ソース・オブ・トゥルースと変更伝播ルール

### 6.1 原則

- **L1**: 要件の変更・追加は必ず L2・L3 に波及させる
- **L2**: 技術上の理由による変更は、L1 に影響しないのが原則。ただし、要求の達成可否に関わる場合は L1 にフィードバックし再合意する
- **L3**: 実装中／運用中に発覚した事項は、影響範囲に応じて L2・L1 に遡って反映する

### 6.2 ケース別ルール

#### ケースA：L1 の変更・追加

**例：**
- 新しいユースケース／画面の要望が追加された
- OS互換性要件が変わった

**対応：**
1. L1 に REQ-YYYYMMDD-nnn として追記／変更し、フロントマターに記載
2. AI で L2 の機能構成案を再生成（差分付き）
3. アーキテクト／PO が L2 の差分をレビュー・承認
4. 影響する機能Doc を AI が抽出し、L3 を新規作成／更新

#### ケースB：L2 の変更

**例：**
- 想定していた技術スタックで要件を満たせないことが判明
- フェーズ構成や機能分割の見直しが必要

**対応（要件自体が変わらない範囲）：**
1. L2 の該当箇所（技術スタック／フェーズ／機能一覧）を更新
2. AI で影響範囲の機能Doc を洗い出し、必要分を更新

**対応（要求の達成可否／品質・コストに大きな影響がある場合）：**
- L1 に戻し、PO／業務側と合意形成した上で、L2 を再確定する

#### ケースC：L3 の変更

**例：**
- 実装中により良い設計パターンが見つかった
- バグ修正でロジック変更が必要になった

**対応（局所的な修正）：**
- 機能Doc とコード／テストのみ更新

**対応（他機能へ影響する／設計レベルの変更）：**
- L2（機能構成・技術方針）にフィードバック

**対応（要求自体の見直しが必要なレベル）：**
- L1 へ戻り、要件の再定義と合意を取る

### 6.3 軽量運用の目安

- 実装のリファクタリングやバグ修正で、L3 の「業務ルール」「入出力」「受け入れ条件」が変わらない場合は、L3 の「実装メモ」への簡単な追記のみでよい（L2/L1 には波及させない）
- 挙動や仕様が変わる場合（ユーザー視点で見える違いがある場合）は、影響範囲に応じて L3 → L2 → L1 の順に遡ってドキュメントを更新する
- ある程度変更が溜まってから、AI に「この範囲のコード変更に基づいて L3/L2 を見直して」と依頼し、まとめて整理し直す運用も許容する

### 6.4 規模別の運用イメージ

**個人開発：**
- 軽微な修正（画面レイアウト微調整、文言変更など）は、L3 のメモに追記するだけでもよい
- REQ やフェーズ構成に影響するような変更が出たときに、まとめて L1/L2 を更新するスタイルでもよい

**小〜中規模チーム：**
- コード変更時に AI に「この PR の変更から見て、影響しそうな L3 / L2 / L1 を教えて」と依頼し、影響箇所を優先的に更新する
- すべてを即時反映するのではなく、「リリース前に必ず全体整合性チェックを AI で走らせる」タイミングを決めておく

---

## 7. AI活用ポリシー

### 7.1 AIの主な役割

#### L1 → L2

- 用語集の抽出
- 機能候補への分解・グルーピング
- フェーズ案の提示
- 非機能カタログ案の起草
- **技術スタック候補の提示（v0.1）**: AIが候補を提示し、ユーザーとの対話を通じて人間が選択

#### L2 → L3

- 機能Doc のドラフト生成（概要・タスク・受入条件案・非機能の具体化）

#### 実装／テスト結果 → 上位層

- **差分検出**: コード／テストと機能Doc、L2 の不整合候補を検出
- **修正案の提案**: どの Doc をどう直すべきかの案を提示

#### 全レイヤ横断の整合性チェック

- 各ドキュメントのフロントマター（id / kind / layer / status）の整合性チェック
- req_ids / nfr_ids / phase / related_nfr_ids などの参照が有効かの検証
- 孤立したID・切れたリンク・誤った参照の検出
- 検出結果のレポート生成、または修正パッチ案（差分）の提示

> 実際の運用では、L1→L2変換、L2→L3生成、整合性チェックなどの用途ごとに標準プロンプト（プロンプトテンプレート）を用意し、プロジェクト内で共有することを想定します。

### 7.2 人間によるレビューと doc_status 管理

**L2：**
- AI がドラフトを生成 → アーキテクト／BA／テックリードがレビュー・承認
- doc_status: draft（AIドラフト）→ reviewed（レビュー済み）

**L3：**
- AI がドラフトを生成 → 担当開発者／テスターがレビュー・補正
- 実装・テスト完了後、doc_status: implemented として確定

> **原則**: AI が生成した内容は、必ずロールに応じた人間のレビューを経て有効化されます。

### 7.3 規模別の運用イメージ

**個人開発：**
- 最初は「L1→L2」「L2→L3」「整合チェック」の3種類程度のプロンプトから始め、必要に応じてカスタマイズしていく

**小〜中規模チーム：**
- リポジトリ内に `ai/` ディレクトリを設け、標準プロンプトと利用ルールを共有する
- 重要な決定（アーキテクチャ方針など）については、AI提案に対する人間の最終判断を PR やコメントとして残す
