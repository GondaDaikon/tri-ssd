---
description: L1からL2（機能設計・技術方針）ドキュメントを生成する
argument-hint: "[REQ-xxxx ...] - 対象の要件ID（省略時は全体）"
allowed-tools: Read, Write, Edit, WebSearch, Glob
---

# L2 生成コマンド

## 引数

- `$ARGUMENTS`: 対象の要件ID（省略可、複数指定可）
  - 指定時: 指定された REQ のみを対象に L2 を生成/更新
  - 省略時: L1 全体を対象に L2 を生成

## 前提処理

1. `.claude/skills/ssdd.md` を読み込み、SSDD の基本概念を把握する
2. `docs/templates/l2_overview.md` を読み込み、L2 概要テンプレートを確認する
3. `docs/templates/l2_phases.md` を読み込み、L2 フェーズテンプレートを確認する
4. `docs/templates/README.md` を読み込み、フロントマター仕様を確認する
5. `docs/l1_vision/vision.md` を読み込み、L1 の内容を把握する

## 実行内容

L1 の要求を分析し、L2 ドキュメント群を生成します。

## 生成手順

### Step 1: L1 分析

- REQ-xxxx の一覧を抽出
- 要件の依存関係を分析
- 非機能要求を分類

### Step 2: 技術スタック検討（WebSearch活用）

技術選定は以下のサブステップで行う。

#### Step 2-1: L1から技術制約を抽出

以下の観点でL1を読み、制約を列挙する：

| 観点 | 確認内容 |
|------|---------|
| 対象プラットフォーム | Web / Desktop / Mobile / 複数 |
| オフライン要件 | オフライン動作が必要か |
| リアルタイム性 | WebSocket等のリアルタイム通信が必要か |
| データ量・パフォーマンス | 大量データ処理、高速レスポンス要件 |
| セキュリティ要件 | 認証方式、データ暗号化等 |
| 明示的な技術指定 | L1で指定された技術があれば最優先 |

**出力例：**
```markdown
## 技術制約（L1より抽出）
- プラットフォーム: Desktop (Windows/macOS)
- オフライン: 必須（REQ-0003）
- リアルタイム: 不要
- パフォーマンス: 1000件以上のデータを遅延なく表示（REQ-0005）
- セキュリティ: ローカル認証のみ
- 明示指定: なし
```

#### Step 2-2: 技術カテゴリごとに候補を検索

以下のカテゴリについて、WebSearchで最新情報を検索：

| カテゴリ | 検索クエリ例 |
|---------|-------------|
| UIフレームワーク | `[プラットフォーム] UI framework comparison 2025` |
| 言語/ランタイム | `[プラットフォーム] programming language 選定 2025` |
| データストア | `[要件] database OSS 比較 2025`（例: オフライン対応、組み込み等） |
| 通信方式 | `realtime communication library 2025`（リアルタイム要件がある場合のみ） |

**検索時の注意：**
- 検索年は現在年（2025）を使用
- OSS/商用の両方を考慮
- メンテナンス状況（最終更新日、コミュニティ活性度）を確認

#### Step 2-3: 制約との照合

各候補について、Step 2-1 の制約を満たすかチェック：

```
候補: [技術名]
├─ 制約1（プラットフォーム）: ✓ 対応 / ✗ 非対応
├─ 制約2（オフライン）: ✓ 対応 / ✗ 非対応
├─ ...
└─ 判定: 採用候補 / 除外（理由: xxx）
```

- 全制約を満たす → 採用候補として残す
- 1つでも満たさない → 除外理由を明記して除外

#### Step 2-4: 組み合わせ整合性の検証

残った候補の組み合わせで以下を確認：

| チェック項目 | 確認内容 |
|-------------|---------|
| 言語統一性 | フロント・バックで言語が異なる場合は明記 |
| ビルド複雑さ | 複数ツールチェーンが必要か |
| 採用実績 | 検索で類似構成の事例があるか確認 |
| エコシステム | ライブラリ・ツールの充実度 |

**検索クエリ例：**
- `[フレームワークA] + [データストアB] 構成 事例`
- `[技術スタック組み合わせ] production 実績`

#### Step 2-5: 選択肢として提示

以下の形式で `docs/l2_system/overview.md` に出力：

```markdown
## 技術選定

### 技術制約（L1より）
- [制約一覧]

### 採用候補
| カテゴリ | 技術 | 選定理由 |
|---------|------|----------|
| UI | [技術名] | L1の[REQ-xxxx]要件を満たす。[検索結果の根拠] |
| 言語 | [技術名] | [理由] |
| データストア | [技術名] | [理由] |

### 不採用候補
| カテゴリ | 技術 | 除外理由 |
|---------|------|----------|
| UI | [技術名] | L1の[REQ-xxxx]要件（[具体的要件]）を満たさないため除外 |

### 確認事項
<!-- TODO: 要確認 -->
- [ ] 最終的な技術選定は人間が確認してください
- [ ] チームの習熟度を考慮して選定を調整してください
- [ ] ライセンス形態がプロジェクトに適合するか確認してください
```

### Step 3: 用語集抽出

L1 からドメイン用語・業務用語を抽出し、定義を記載

### Step 4: 機能分解

REQ を F-xxxx（機能）に分解：

- 1つの REQ から複数の F が生まれることがある
- F 間の依存関係を明確化
- 各 F に対応する REQ を `req_ids` に記録

### Step 5: フェーズ設計

機能群を PH-xxxx（フェーズ）にグルーピング：

- 「結合して動かして意味がある」単位で束ねる
- 各フェーズの Exit Criteria を定義
- フェーズ内の機能は実装順に並べる

### Step 6: 非機能カタログ作成

L1 の高レベル非機能要求を NF-xxxx に具体化

## 出力ファイル

| ファイル | 内容 |
|---------|------|
| `docs/l2_system/overview.md` | 用語集・技術方針・全体構成 |
| `docs/l2_system/phases.md` | フェーズ定義 |
| `docs/l2_system/nfr.md` | 非機能要求カタログ |
| `docs/l2_system/features_index.md` | 機能一覧（全体俯瞰用） |

## 出力仕様

- **フロントマター**: `doc_status: draft` で開始
- **曖昧箇所**: `<!-- TODO: 要確認 -->` でマーク
- **参照フィールド**: `req_ids`, `related_nfr_ids` を正確に記載

## 完了後の案内

- 生成したファイルのパスを報告
- 抽出した F-xxxx, PH-xxxx, NF-xxxx の数を報告
- `/gen-l3` で L3 を生成できることを案内
- 技術選定でユーザー判断が必要な箇所を明示
