# SSDD トラブルシューティング・ベストプラクティス

> このスキルは問題解決とベストプラクティスを提供します。エラー発生時や運用改善時に参照してください。

## トラブルシューティング

### 問題1: ID衝突が発生した

**症状**: `/check` で "ID重複エラー" が表示される

**原因**: 手動でIDを付与した際に既存IDと重複

**解決方法**:
```bash
# 1. 既存ID一覧を確認
/check --list-ids

# 2. 重複IDを別のIDに変更
# → ファイルのフロントマター `id` フィールドを修正

# 3. 参照も更新
# → 他のファイルの req_ids, nfr_ids, phase 等も修正

# 4. 再チェック
/check
```

### 問題2: 参照整合性エラー

**症状**: `/check` で "参照先が存在しません: REQ-20250125-001"

**原因**: フロントマターの `req_ids` に存在しないIDを指定

**解決方法**:
```bash
# 1. 存在するIDを確認
/check --list-ids

# 2. 参照元ファイルを修正
# → req_ids, nfr_ids, phase フィールドを正しいIDに修正

# 3. 参照先が本当に必要な場合は作成
/draft-l1  # 新しいREQを追加

# 4. 再チェック
/check
```

### 問題3: タイトル見出しが欠落（v2.0）

**症状**: `/check` で "タイトル見出しが欠落しています"

**原因**: フロントマター直後に `# 見出し` が存在しない

**解決方法**:
```markdown
# 修正前
---
id: F-20250125-001
kind: feature
layer: L3
---

## 概要  # ← 2階層目の見出しから始まっている

# 修正後
---
id: F-20250125-001
kind: feature
layer: L3
---

# ユーザー登録機能  # ← 1階層目の見出しを追加

## 概要
```

### 問題4: フェーズとイテレーションの混同（v2.2）

**症状**: フェーズが1週間単位で細かく分割されている

**原因**: フェーズ（機能的マイルストーン）とイテレーション（時間的マイルストーン）を混同

**解決方法**:
- **フェーズ**: 「意味のある機能群」で定義（例: "基盤構築", "コア機能"）
- **イテレーション**: 別管理（Jira/GitHub Projects等）
- 1フェーズが複数イテレーションにまたがることを許容
- 詳細: `docs/guide.md` の「フェーズとイテレーションの関係（v2.2明確化）」参照

### 問題5: doc_status 昇格条件を満たさない

**症状**: `/promote-status` で "昇格条件を満たしていません"

**原因**: draft → reviewed の遷移時に必須条件未達成

**解決方法**:
```bash
# 1. エラー内容を確認
/promote-status docs/l3_features/F-20250125-001_xxx.md
# → "TODO が 3箇所残存しています"
# → "参照整合性エラーが 1件あります"

# 2. 指摘事項を修正
# → TODO コメントを削除または解決
# → 参照IDを修正

# 3. 再試行
/promote-status docs/l3_features/F-20250125-001_xxx.md
```

### 問題6: ライト版から標準版への移行

**症状**: 既存プロジェクトがライト版運用で、標準版に移行したい

**解決方法**:
- v2.3以降、ライト版は廃止されました
- 詳細: `docs/checklists.md` の「v2.3変更点: ライト版の廃止」
- 移行ガイド: `docs/checklists.md` の「3.4 移行ガイド（既存ライト版運用からの移行）」参照

```bash
# 段階的移行の基本フロー
# 1. 現状把握
/check --list-ids

# 2. 構造整備
/init-ssdd  # 標準ディレクトリ構造を作成
# → 既存ファイルを標準構造に移動

# 3. フロントマター追加
# → 既存ドキュメントにフロントマターを追加

# 4. ID統一
# → 新規IDはv2.0形式（REQ-YYYYMMDD-nnn）を使用

# 5. 整合性チェック
/check
```

---

## ベストプラクティス

### 1. 定期的な整合性チェック

```bash
# リリース前
/check

# 大きな変更後
/check

# 週次
/check --list-ids  # ID一覧を確認
```

### 2. doc_status 管理の徹底

- **draft**: AI生成直後、必ず人間がレビュー
- **reviewed**: 実装可能なレベル、TODOは解消
- **implemented**: コードと同期、プレースホルダー残存なし

```bash
# 昇格前に必ずレビュー
/review docs/l3_features/F-20250125-001_xxx.md
/promote-status docs/l3_features/F-20250125-001_xxx.md
```

### 3. 変更伝播の明確化

```bash
# L1変更時
/propagate-change docs/l1_vision.md

# 影響範囲を確認してから更新
# → L2, L3 の該当箇所を修正
```

### 4. フェーズ設計のポイント

- **粒度**: 2-8個のフェーズが目安
- **完了条件**: Exit Criteria を明確に定義
- **依存関係**: フェーズ間の依存を最小化
- **テスト**: フェーズ境界で結合テスト実施

### 5. ドメイン特化テンプレートの活用（v2.1）

```bash
# Webアプリの場合
/gen-l3 F-20250125-001 --template web

# CLIツールの場合
/gen-l3 F-20250125-001 --template cli
```
